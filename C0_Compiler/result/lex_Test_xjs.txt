28	CONSTYP	const	row:1	colmn:0
25	INTYP	int	row:1	colmn:1
2	IDEN	cona	row:1	colmn:2
5	ASSIGN	=	row:1	colmn:3
1	INT	10	row:1	colmn:4
9	SEMI	;	row:1	colmn:5
28	CONSTYP	const	row:2	colmn:0
26	CHARTYP	char	row:2	colmn:1
2	IDEN	conb	row:2	colmn:2
5	ASSIGN	=	row:2	colmn:3
3	CHR	'a'	row:2	colmn:4
8	COMMA	,	row:2	colmn:5
2	IDEN	conc	row:2	colmn:6
5	ASSIGN	=	row:2	colmn:7
3	CHR	'6'	row:2	colmn:8
9	SEMI	;	row:2	colmn:9
25	INTYP	int	row:3	colmn:0
2	IDEN	_cha	row:3	colmn:1
8	COMMA	,	row:3	colmn:2
2	IDEN	chb	row:3	colmn:3
13	LBRAK	[	row:3	colmn:4
1	INT	6	row:3	colmn:5
14	RBRAK	]	row:3	colmn:6
9	SEMI	;	row:3	colmn:7
26	CHARTYP	char	row:4	colmn:0
2	IDEN	chc	row:4	colmn:1
8	COMMA	,	row:4	colmn:2
2	IDEN	chd	row:4	colmn:3
9	SEMI	;	row:4	colmn:4
25	INTYP	int	row:5	colmn:0
2	IDEN	f	row:5	colmn:1
11	LPAR	(	row:5	colmn:2
25	INTYP	int	row:5	colmn:3
2	IDEN	x	row:5	colmn:4
8	COMMA	,	row:5	colmn:5
25	INTYP	int	row:5	colmn:6
2	IDEN	y	row:5	colmn:7
12	RPAR	)	row:5	colmn:8
6	LCURB	{	row:5	colmn:9
28	CONSTYP	const	row:6	colmn:0
25	INTYP	int	row:6	colmn:1
2	IDEN	z	row:6	colmn:2
5	ASSIGN	=	row:6	colmn:3
1	INT	1	row:6	colmn:4
9	SEMI	;	row:6	colmn:5
29	IFSY	if	row:7	colmn:0
11	LPAR	(	row:7	colmn:1
2	IDEN	x	row:7	colmn:2
19	GT	>	row:7	colmn:3
1	INT	1	row:7	colmn:4
12	RPAR	)	row:7	colmn:5
34	RETURNSY	return	row:7	colmn:6
11	LPAR	(	row:7	colmn:7
2	IDEN	x	row:7	colmn:8
15	PLUS	+	row:7	colmn:9
2	IDEN	z	row:7	colmn:10
12	RPAR	)	row:7	colmn:11
9	SEMI	;	row:7	colmn:12
2	IDEN	x	row:8	colmn:0
5	ASSIGN	=	row:8	colmn:1
2	IDEN	x	row:8	colmn:2
15	PLUS	+	row:8	colmn:3
1	INT	1	row:8	colmn:4
9	SEMI	;	row:8	colmn:5
2	IDEN	f	row:8	colmn:6
11	LPAR	(	row:8	colmn:7
2	IDEN	x	row:8	colmn:8
8	COMMA	,	row:8	colmn:9
2	IDEN	y	row:8	colmn:10
12	RPAR	)	row:8	colmn:11
9	SEMI	;	row:8	colmn:12
34	RETURNSY	return	row:9	colmn:0
11	LPAR	(	row:9	colmn:1
2	IDEN	x	row:9	colmn:2
15	PLUS	+	row:9	colmn:3
2	IDEN	y	row:9	colmn:4
12	RPAR	)	row:9	colmn:5
9	SEMI	;	row:9	colmn:6
7	RCURB	}	row:10	colmn:0
25	INTYP	int	row:11	colmn:0
2	IDEN	compare	row:11	colmn:1
11	LPAR	(	row:11	colmn:2
25	INTYP	int	row:11	colmn:3
2	IDEN	a	row:11	colmn:4
8	COMMA	,	row:11	colmn:5
25	INTYP	int	row:11	colmn:6
2	IDEN	b	row:11	colmn:7
12	RPAR	)	row:11	colmn:8
6	LCURB	{	row:11	colmn:9
29	IFSY	if	row:12	colmn:0
11	LPAR	(	row:12	colmn:1
2	IDEN	a	row:12	colmn:2
19	GT	>	row:12	colmn:3
2	IDEN	b	row:12	colmn:4
12	RPAR	)	row:12	colmn:5
34	RETURNSY	return	row:12	colmn:6
11	LPAR	(	row:12	colmn:7
1	INT	1	row:12	colmn:8
12	RPAR	)	row:12	colmn:9
9	SEMI	;	row:12	colmn:10
29	IFSY	if	row:13	colmn:0
11	LPAR	(	row:13	colmn:1
2	IDEN	a	row:13	colmn:2
22	LSEQU	<=	row:13	colmn:3
2	IDEN	b	row:13	colmn:4
12	RPAR	)	row:13	colmn:5
34	RETURNSY	return	row:13	colmn:6
11	LPAR	(	row:13	colmn:7
16	MINUS	-	row:13	colmn:8
1	INT	1	row:13	colmn:9
12	RPAR	)	row:13	colmn:10
9	SEMI	;	row:13	colmn:11
7	RCURB	}	row:14	colmn:0
27	NOTYP	void	row:16	colmn:0
2	IDEN	line	row:16	colmn:1
11	LPAR	(	row:16	colmn:2
25	INTYP	int	row:16	colmn:3
2	IDEN	n	row:16	colmn:4
8	COMMA	,	row:16	colmn:5
25	INTYP	int	row:16	colmn:6
2	IDEN	m	row:16	colmn:7
12	RPAR	)	row:16	colmn:8
6	LCURB	{	row:16	colmn:9
25	INTYP	int	row:17	colmn:0
2	IDEN	i	row:17	colmn:1
8	COMMA	,	row:17	colmn:2
2	IDEN	j	row:17	colmn:3
8	COMMA	,	row:17	colmn:4
2	IDEN	stpos	row:17	colmn:5
13	LBRAK	[	row:17	colmn:6
1	INT	100	row:17	colmn:7
14	RBRAK	]	row:17	colmn:8
8	COMMA	,	row:17	colmn:9
2	IDEN	posst	row:17	colmn:10
13	LBRAK	[	row:17	colmn:11
1	INT	100	row:17	colmn:12
14	RBRAK	]	row:17	colmn:13
9	SEMI	;	row:17	colmn:14
25	INTYP	int	row:18	colmn:0
2	IDEN	p	row:18	colmn:1
8	COMMA	,	row:18	colmn:2
2	IDEN	q	row:18	colmn:3
8	COMMA	,	row:18	colmn:4
2	IDEN	move	row:18	colmn:5
8	COMMA	,	row:18	colmn:6
2	IDEN	end	row:18	colmn:7
8	COMMA	,	row:18	colmn:8
2	IDEN	po1	row:18	colmn:9
8	COMMA	,	row:18	colmn:10
2	IDEN	po2	row:18	colmn:11
8	COMMA	,	row:18	colmn:12
2	IDEN	st2	row:18	colmn:13
9	SEMI	;	row:18	colmn:14
2	IDEN	i	row:19	colmn:0
5	ASSIGN	=	row:19	colmn:1
1	INT	1	row:19	colmn:2
9	SEMI	;	row:19	colmn:3
2	IDEN	j	row:19	colmn:4
5	ASSIGN	=	row:19	colmn:5
1	INT	1	row:19	colmn:6
9	SEMI	;	row:19	colmn:7
30	DOSY	do	row:20	colmn:0
6	LCURB	{	row:20	colmn:1
2	IDEN	stpos	row:21	colmn:0
13	LBRAK	[	row:21	colmn:1
2	IDEN	i	row:21	colmn:2
14	RBRAK	]	row:21	colmn:3
5	ASSIGN	=	row:21	colmn:4
2	IDEN	i	row:21	colmn:5
9	SEMI	;	row:21	colmn:6
2	IDEN	posst	row:22	colmn:0
13	LBRAK	[	row:22	colmn:1
2	IDEN	i	row:22	colmn:2
14	RBRAK	]	row:22	colmn:3
5	ASSIGN	=	row:22	colmn:4
2	IDEN	i	row:22	colmn:5
9	SEMI	;	row:22	colmn:6
2	IDEN	i	row:23	colmn:0
5	ASSIGN	=	row:23	colmn:1
2	IDEN	i	row:23	colmn:2
15	PLUS	+	row:23	colmn:3
1	INT	1	row:23	colmn:4
9	SEMI	;	row:23	colmn:5
7	RCURB	}	row:24	colmn:0
31	WHILESY	while	row:24	colmn:1
11	LPAR	(	row:24	colmn:2
2	IDEN	i	row:24	colmn:3
22	LSEQU	<=	row:24	colmn:4
2	IDEN	n	row:24	colmn:5
12	RPAR	)	row:24	colmn:6
2	IDEN	i	row:25	colmn:0
5	ASSIGN	=	row:25	colmn:1
1	INT	1	row:25	colmn:2
9	SEMI	;	row:25	colmn:3
30	DOSY	do	row:26	colmn:0
6	LCURB	{	row:26	colmn:1
29	IFSY	if	row:27	colmn:0
11	LPAR	(	row:27	colmn:1
2	IDEN	i	row:27	colmn:2
23	EQU	==	row:27	colmn:3
1	INT	1	row:27	colmn:4
12	RPAR	)	row:27	colmn:5
6	LCURB	{	row:27	colmn:6
2	IDEN	p	row:28	colmn:0
5	ASSIGN	=	row:28	colmn:1
1	INT	3	row:28	colmn:2
9	SEMI	;	row:28	colmn:3
2	IDEN	q	row:28	colmn:4
5	ASSIGN	=	row:28	colmn:5
1	INT	2	row:28	colmn:6
9	SEMI	;	row:28	colmn:7
7	RCURB	}	row:29	colmn:0
29	IFSY	if	row:30	colmn:0
11	LPAR	(	row:30	colmn:1
2	IDEN	i	row:30	colmn:2
23	EQU	==	row:30	colmn:3
1	INT	2	row:30	colmn:4
12	RPAR	)	row:30	colmn:5
6	LCURB	{	row:30	colmn:6
2	IDEN	p	row:31	colmn:0
5	ASSIGN	=	row:31	colmn:1
1	INT	8	row:31	colmn:2
9	SEMI	;	row:31	colmn:3
2	IDEN	q	row:31	colmn:4
5	ASSIGN	=	row:31	colmn:5
16	MINUS	-	row:31	colmn:6
1	INT	3	row:31	colmn:7
9	SEMI	;	row:31	colmn:8
7	RCURB	}	row:32	colmn:0
29	IFSY	if	row:33	colmn:0
11	LPAR	(	row:33	colmn:1
2	IDEN	i	row:33	colmn:2
23	EQU	==	row:33	colmn:3
1	INT	3	row:33	colmn:4
12	RPAR	)	row:33	colmn:5
6	LCURB	{	row:33	colmn:6
2	IDEN	p	row:34	colmn:0
5	ASSIGN	=	row:34	colmn:1
1	INT	3	row:34	colmn:2
9	SEMI	;	row:34	colmn:3
2	IDEN	q	row:34	colmn:4
5	ASSIGN	=	row:34	colmn:5
16	MINUS	-	row:34	colmn:6
1	INT	2	row:34	colmn:7
9	SEMI	;	row:34	colmn:8
7	RCURB	}	row:35	colmn:0
29	IFSY	if	row:36	colmn:0
11	LPAR	(	row:36	colmn:1
2	IDEN	q	row:36	colmn:2
24	NEQU	!=	row:36	colmn:3
1	INT	0	row:36	colmn:4
12	RPAR	)	row:36	colmn:5
6	LCURB	{	row:36	colmn:6
2	IDEN	move	row:37	colmn:0
5	ASSIGN	=	row:37	colmn:1
2	IDEN	compare	row:37	colmn:2
11	LPAR	(	row:37	colmn:3
2	IDEN	q	row:37	colmn:4
8	COMMA	,	row:37	colmn:5
1	INT	0	row:37	colmn:6
12	RPAR	)	row:37	colmn:7
9	SEMI	;	row:37	colmn:8
2	IDEN	end	row:38	colmn:0
5	ASSIGN	=	row:38	colmn:1
2	IDEN	move	row:38	colmn:2
17	STAR	*	row:38	colmn:3
2	IDEN	q	row:38	colmn:4
9	SEMI	;	row:38	colmn:5
2	IDEN	po1	row:39	colmn:0
5	ASSIGN	=	row:39	colmn:1
2	IDEN	stpos	row:39	colmn:2
13	LBRAK	[	row:39	colmn:3
2	IDEN	p	row:39	colmn:4
14	RBRAK	]	row:39	colmn:5
9	SEMI	;	row:39	colmn:6
30	DOSY	do	row:40	colmn:0
6	LCURB	{	row:40	colmn:1
2	IDEN	st2	row:41	colmn:0
5	ASSIGN	=	row:41	colmn:1
2	IDEN	posst	row:41	colmn:2
13	LBRAK	[	row:41	colmn:3
2	IDEN	po1	row:41	colmn:4
15	PLUS	+	row:41	colmn:5
2	IDEN	move	row:41	colmn:6
14	RBRAK	]	row:41	colmn:7
9	SEMI	;	row:41	colmn:8
2	IDEN	po2	row:42	colmn:0
5	ASSIGN	=	row:42	colmn:1
2	IDEN	stpos	row:42	colmn:2
13	LBRAK	[	row:42	colmn:3
2	IDEN	st2	row:42	colmn:4
14	RBRAK	]	row:42	colmn:5
9	SEMI	;	row:42	colmn:6
2	IDEN	posst	row:43	colmn:0
13	LBRAK	[	row:43	colmn:1
2	IDEN	po1	row:43	colmn:2
14	RBRAK	]	row:43	colmn:3
5	ASSIGN	=	row:43	colmn:4
2	IDEN	st2	row:43	colmn:5
9	SEMI	;	row:43	colmn:6
2	IDEN	stpos	row:44	colmn:0
13	LBRAK	[	row:44	colmn:1
2	IDEN	st2	row:44	colmn:2
14	RBRAK	]	row:44	colmn:3
5	ASSIGN	=	row:44	colmn:4
2	IDEN	po1	row:44	colmn:5
9	SEMI	;	row:44	colmn:6
2	IDEN	po1	row:45	colmn:0
5	ASSIGN	=	row:45	colmn:1
2	IDEN	po2	row:45	colmn:2
9	SEMI	;	row:45	colmn:3
2	IDEN	j	row:46	colmn:0
5	ASSIGN	=	row:46	colmn:1
2	IDEN	j	row:46	colmn:2
15	PLUS	+	row:46	colmn:3
1	INT	1	row:46	colmn:4
9	SEMI	;	row:46	colmn:5
7	RCURB	}	row:47	colmn:0
31	WHILESY	while	row:47	colmn:1
11	LPAR	(	row:47	colmn:2
2	IDEN	j	row:47	colmn:3
22	LSEQU	<=	row:47	colmn:4
2	IDEN	end	row:47	colmn:5
12	RPAR	)	row:47	colmn:6
2	IDEN	posst	row:48	colmn:0
13	LBRAK	[	row:48	colmn:1
2	IDEN	po2	row:48	colmn:2
14	RBRAK	]	row:48	colmn:3
5	ASSIGN	=	row:48	colmn:4
2	IDEN	p	row:48	colmn:5
9	SEMI	;	row:48	colmn:6
2	IDEN	stpos	row:49	colmn:0
13	LBRAK	[	row:49	colmn:1
2	IDEN	p	row:49	colmn:2
14	RBRAK	]	row:49	colmn:3
5	ASSIGN	=	row:49	colmn:4
2	IDEN	stpos	row:49	colmn:5
13	LBRAK	[	row:49	colmn:6
2	IDEN	p	row:49	colmn:7
14	RBRAK	]	row:49	colmn:8
15	PLUS	+	row:49	colmn:9
2	IDEN	q	row:49	colmn:10
9	SEMI	;	row:49	colmn:11
7	RCURB	}	row:50	colmn:0
2	IDEN	i	row:51	colmn:0
5	ASSIGN	=	row:51	colmn:1
2	IDEN	i	row:51	colmn:2
15	PLUS	+	row:51	colmn:3
1	INT	1	row:51	colmn:4
9	SEMI	;	row:51	colmn:5
7	RCURB	}	row:52	colmn:0
31	WHILESY	while	row:52	colmn:1
11	LPAR	(	row:52	colmn:2
2	IDEN	i	row:52	colmn:3
22	LSEQU	<=	row:52	colmn:4
2	IDEN	m	row:52	colmn:5
12	RPAR	)	row:52	colmn:6
35	PRINTFUNC	printf	row:53	colmn:0
11	LPAR	(	row:53	colmn:1
2	IDEN	posst	row:53	colmn:2
13	LBRAK	[	row:53	colmn:3
1	INT	1	row:53	colmn:4
14	RBRAK	]	row:53	colmn:5
12	RPAR	)	row:53	colmn:6
9	SEMI	;	row:53	colmn:7
2	IDEN	i	row:54	colmn:0
5	ASSIGN	=	row:54	colmn:1
1	INT	2	row:54	colmn:2
9	SEMI	;	row:54	colmn:3
30	DOSY	do	row:55	colmn:0
6	LCURB	{	row:55	colmn:1
35	PRINTFUNC	printf	row:56	colmn:0
11	LPAR	(	row:56	colmn:1
2	IDEN	posst	row:56	colmn:2
13	LBRAK	[	row:56	colmn:3
2	IDEN	i	row:56	colmn:4
14	RBRAK	]	row:56	colmn:5
12	RPAR	)	row:56	colmn:6
9	SEMI	;	row:56	colmn:7
2	IDEN	i	row:57	colmn:0
5	ASSIGN	=	row:57	colmn:1
2	IDEN	i	row:57	colmn:2
15	PLUS	+	row:57	colmn:3
1	INT	1	row:57	colmn:4
9	SEMI	;	row:57	colmn:5
7	RCURB	}	row:58	colmn:0
31	WHILESY	while	row:58	colmn:1
11	LPAR	(	row:58	colmn:2
2	IDEN	i	row:58	colmn:3
22	LSEQU	<=	row:58	colmn:4
2	IDEN	n	row:58	colmn:5
12	RPAR	)	row:58	colmn:6
34	RETURNSY	return	row:59	colmn:0
9	SEMI	;	row:59	colmn:1
7	RCURB	}	row:60	colmn:0
26	CHARTYP	char	row:61	colmn:0
2	IDEN	f2	row:61	colmn:1
11	LPAR	(	row:61	colmn:2
26	CHARTYP	char	row:61	colmn:3
2	IDEN	x	row:61	colmn:4
12	RPAR	)	row:61	colmn:5
6	LCURB	{	row:61	colmn:6
25	INTYP	int	row:62	colmn:0
2	IDEN	z2	row:62	colmn:1
9	SEMI	;	row:62	colmn:2
2	IDEN	z2	row:63	colmn:0
5	ASSIGN	=	row:63	colmn:1
1	INT	1	row:63	colmn:2
9	SEMI	;	row:63	colmn:3
2	IDEN	x	row:64	colmn:0
5	ASSIGN	=	row:64	colmn:1
2	IDEN	x	row:64	colmn:2
15	PLUS	+	row:64	colmn:3
2	IDEN	z2	row:64	colmn:4
9	SEMI	;	row:64	colmn:5
34	RETURNSY	return	row:65	colmn:0
11	LPAR	(	row:65	colmn:1
2	IDEN	x	row:65	colmn:2
12	RPAR	)	row:65	colmn:3
9	SEMI	;	row:65	colmn:4
7	RCURB	}	row:66	colmn:0
25	INTYP	int	row:67	colmn:0
2	IDEN	fib	row:67	colmn:1
11	LPAR	(	row:67	colmn:2
25	INTYP	int	row:67	colmn:3
2	IDEN	n	row:67	colmn:4
12	RPAR	)	row:67	colmn:5
6	LCURB	{	row:67	colmn:6
25	INTYP	int	row:68	colmn:0
2	IDEN	result	row:68	colmn:1
9	SEMI	;	row:68	colmn:2
29	IFSY	if	row:69	colmn:0
11	LPAR	(	row:69	colmn:1
2	IDEN	n	row:69	colmn:2
23	EQU	==	row:69	colmn:3
1	INT	0	row:69	colmn:4
12	RPAR	)	row:69	colmn:5
34	RETURNSY	return	row:69	colmn:6
11	LPAR	(	row:69	colmn:7
1	INT	0	row:69	colmn:8
12	RPAR	)	row:69	colmn:9
9	SEMI	;	row:69	colmn:10
29	IFSY	if	row:70	colmn:0
11	LPAR	(	row:70	colmn:1
2	IDEN	n	row:70	colmn:2
23	EQU	==	row:70	colmn:3
1	INT	1	row:70	colmn:4
12	RPAR	)	row:70	colmn:5
34	RETURNSY	return	row:70	colmn:6
11	LPAR	(	row:70	colmn:7
1	INT	1	row:70	colmn:8
12	RPAR	)	row:70	colmn:9
9	SEMI	;	row:70	colmn:10
2	IDEN	result	row:71	colmn:0
5	ASSIGN	=	row:71	colmn:1
2	IDEN	fib	row:71	colmn:2
11	LPAR	(	row:71	colmn:3
2	IDEN	n	row:71	colmn:4
16	MINUS	-	row:71	colmn:5
1	INT	1	row:71	colmn:6
12	RPAR	)	row:71	colmn:7
15	PLUS	+	row:71	colmn:8
2	IDEN	fib	row:71	colmn:9
11	LPAR	(	row:71	colmn:10
2	IDEN	n	row:71	colmn:11
16	MINUS	-	row:71	colmn:12
1	INT	2	row:71	colmn:13
12	RPAR	)	row:71	colmn:14
9	SEMI	;	row:71	colmn:15
34	RETURNSY	return	row:72	colmn:0
11	LPAR	(	row:72	colmn:1
2	IDEN	result	row:72	colmn:2
12	RPAR	)	row:72	colmn:3
9	SEMI	;	row:72	colmn:4
7	RCURB	}	row:74	colmn:0
27	NOTYP	void	row:75	colmn:0
2	IDEN	nest	row:75	colmn:1
11	LPAR	(	row:75	colmn:2
12	RPAR	)	row:75	colmn:3
6	LCURB	{	row:75	colmn:4
25	INTYP	int	row:76	colmn:0
2	IDEN	a	row:76	colmn:1
13	LBRAK	[	row:76	colmn:2
1	INT	15	row:76	colmn:3
14	RBRAK	]	row:76	colmn:4
9	SEMI	;	row:76	colmn:5
25	INTYP	int	row:77	colmn:0
2	IDEN	b	row:77	colmn:1
13	LBRAK	[	row:77	colmn:2
1	INT	15	row:77	colmn:3
14	RBRAK	]	row:77	colmn:4
9	SEMI	;	row:77	colmn:5
2	IDEN	a	row:78	colmn:0
13	LBRAK	[	row:78	colmn:1
1	INT	0	row:78	colmn:2
14	RBRAK	]	row:78	colmn:3
5	ASSIGN	=	row:78	colmn:4
1	INT	1	row:78	colmn:5
9	SEMI	;	row:78	colmn:6
2	IDEN	b	row:79	colmn:0
13	LBRAK	[	row:79	colmn:1
1	INT	1	row:79	colmn:2
14	RBRAK	]	row:79	colmn:3
5	ASSIGN	=	row:79	colmn:4
1	INT	3	row:79	colmn:5
9	SEMI	;	row:79	colmn:6
2	IDEN	a	row:80	colmn:0
13	LBRAK	[	row:80	colmn:1
1	INT	3	row:80	colmn:2
14	RBRAK	]	row:80	colmn:3
5	ASSIGN	=	row:80	colmn:4
1	INT	4	row:80	colmn:5
9	SEMI	;	row:80	colmn:6
2	IDEN	b	row:81	colmn:0
13	LBRAK	[	row:81	colmn:1
1	INT	4	row:81	colmn:2
14	RBRAK	]	row:81	colmn:3
5	ASSIGN	=	row:81	colmn:4
1	INT	6	row:81	colmn:5
9	SEMI	;	row:81	colmn:6
2	IDEN	a	row:82	colmn:0
13	LBRAK	[	row:82	colmn:1
1	INT	6	row:82	colmn:2
14	RBRAK	]	row:82	colmn:3
5	ASSIGN	=	row:82	colmn:4
1	INT	8	row:82	colmn:5
9	SEMI	;	row:82	colmn:6
2	IDEN	b	row:83	colmn:0
13	LBRAK	[	row:83	colmn:1
2	IDEN	a	row:83	colmn:2
13	LBRAK	[	row:83	colmn:3
2	IDEN	b	row:83	colmn:4
13	LBRAK	[	row:83	colmn:5
2	IDEN	a	row:83	colmn:6
13	LBRAK	[	row:83	colmn:7
2	IDEN	b	row:83	colmn:8
13	LBRAK	[	row:83	colmn:9
2	IDEN	a	row:83	colmn:10
13	LBRAK	[	row:83	colmn:11
1	INT	0	row:83	colmn:12
14	RBRAK	]	row:83	colmn:13
14	RBRAK	]	row:83	colmn:14
14	RBRAK	]	row:83	colmn:15
14	RBRAK	]	row:83	colmn:16
14	RBRAK	]	row:83	colmn:17
14	RBRAK	]	row:83	colmn:18
5	ASSIGN	=	row:83	colmn:19
1	INT	2333	row:83	colmn:20
9	SEMI	;	row:83	colmn:21
35	PRINTFUNC	printf	row:84	colmn:0
11	LPAR	(	row:84	colmn:1
2	IDEN	a	row:84	colmn:2
13	LBRAK	[	row:84	colmn:3
1	INT	0	row:84	colmn:4
14	RBRAK	]	row:84	colmn:5
15	PLUS	+	row:84	colmn:6
2	IDEN	b	row:84	colmn:7
13	LBRAK	[	row:84	colmn:8
1	INT	8	row:84	colmn:9
14	RBRAK	]	row:84	colmn:10
12	RPAR	)	row:84	colmn:11
9	SEMI	;	row:84	colmn:12
34	RETURNSY	return	row:85	colmn:0
9	SEMI	;	row:85	colmn:1
7	RCURB	}	row:86	colmn:0
27	NOTYP	void	row:87	colmn:0
2	IDEN	t	row:87	colmn:1
11	LPAR	(	row:87	colmn:2
26	CHARTYP	char	row:87	colmn:3
2	IDEN	x	row:87	colmn:4
12	RPAR	)	row:87	colmn:5
6	LCURB	{	row:87	colmn:6
29	IFSY	if	row:88	colmn:0
11	LPAR	(	row:88	colmn:1
2	IDEN	x	row:88	colmn:2
19	GT	>	row:88	colmn:3
3	CHR	'c'	row:88	colmn:4
12	RPAR	)	row:88	colmn:5
34	RETURNSY	return	row:88	colmn:6
9	SEMI	;	row:88	colmn:7
2	IDEN	x	row:89	colmn:0
5	ASSIGN	=	row:89	colmn:1
2	IDEN	x	row:89	colmn:2
15	PLUS	+	row:89	colmn:3
1	INT	1	row:89	colmn:4
9	SEMI	;	row:89	colmn:5
35	PRINTFUNC	printf	row:90	colmn:0
11	LPAR	(	row:90	colmn:1
2	IDEN	x	row:90	colmn:2
12	RPAR	)	row:90	colmn:3
9	SEMI	;	row:90	colmn:4
2	IDEN	t	row:91	colmn:0
11	LPAR	(	row:91	colmn:1
2	IDEN	x	row:91	colmn:2
12	RPAR	)	row:91	colmn:3
9	SEMI	;	row:91	colmn:4
34	RETURNSY	return	row:92	colmn:0
9	SEMI	;	row:92	colmn:1
7	RCURB	}	row:93	colmn:0
27	NOTYP	void	row:94	colmn:0
37	MAINFUNC	main	row:94	colmn:1
11	LPAR	(	row:94	colmn:2
12	RPAR	)	row:94	colmn:3
6	LCURB	{	row:95	colmn:0
28	CONSTYP	const	row:96	colmn:0
25	INTYP	int	row:96	colmn:1
2	IDEN	coz	row:96	colmn:2
5	ASSIGN	=	row:96	colmn:3
1	INT	3	row:96	colmn:4
9	SEMI	;	row:96	colmn:5
25	INTYP	int	row:97	colmn:0
2	IDEN	a	row:97	colmn:1
8	COMMA	,	row:97	colmn:2
2	IDEN	b	row:97	colmn:3
8	COMMA	,	row:97	colmn:4
2	IDEN	c	row:97	colmn:5
8	COMMA	,	row:97	colmn:6
2	IDEN	d	row:97	colmn:7
8	COMMA	,	row:97	colmn:8
2	IDEN	key	row:97	colmn:9
8	COMMA	,	row:97	colmn:10
2	IDEN	i	row:97	colmn:11
8	COMMA	,	row:97	colmn:12
2	IDEN	sz2	row:97	colmn:13
13	LBRAK	[	row:97	colmn:14
1	INT	5	row:97	colmn:15
14	RBRAK	]	row:97	colmn:16
9	SEMI	;	row:97	colmn:17
25	INTYP	int	row:98	colmn:0
2	IDEN	cho	row:98	colmn:1
9	SEMI	;	row:98	colmn:2
26	CHARTYP	char	row:99	colmn:0
2	IDEN	sz	row:99	colmn:1
13	LBRAK	[	row:99	colmn:2
1	INT	5	row:99	colmn:3
14	RBRAK	]	row:99	colmn:4
8	COMMA	,	row:99	colmn:5
2	IDEN	e	row:99	colmn:6
9	SEMI	;	row:99	colmn:7
2	IDEN	chc	row:100	colmn:0
5	ASSIGN	=	row:100	colmn:1
3	CHR	'+'	row:100	colmn:2
9	SEMI	;	row:100	colmn:3
2	IDEN	chd	row:101	colmn:0
5	ASSIGN	=	row:101	colmn:1
3	CHR	'-'	row:101	colmn:2
9	SEMI	;	row:101	colmn:3
2	IDEN	b	row:102	colmn:0
5	ASSIGN	=	row:102	colmn:1
15	PLUS	+	row:102	colmn:2
1	INT	3	row:102	colmn:3
9	SEMI	;	row:102	colmn:4
2	IDEN	i	row:103	colmn:0
5	ASSIGN	=	row:103	colmn:1
1	INT	0	row:103	colmn:2
9	SEMI	;	row:103	colmn:3
2	IDEN	c	row:104	colmn:0
5	ASSIGN	=	row:104	colmn:1
16	MINUS	-	row:104	colmn:2
1	INT	2	row:104	colmn:3
9	SEMI	;	row:104	colmn:4
2	IDEN	key	row:105	colmn:0
5	ASSIGN	=	row:105	colmn:1
1	INT	1	row:105	colmn:2
9	SEMI	;	row:105	colmn:3
36	SCANFUNC	scanf	row:106	colmn:0
11	LPAR	(	row:106	colmn:1
2	IDEN	cho	row:106	colmn:2
12	RPAR	)	row:106	colmn:3
9	SEMI	;	row:106	colmn:4
32	SWITCHSY	switch	row:107	colmn:0
11	LPAR	(	row:107	colmn:1
2	IDEN	cho	row:107	colmn:2
12	RPAR	)	row:107	colmn:3
6	LCURB	{	row:107	colmn:4
33	CASESY	case	row:108	colmn:0
1	INT	0	row:108	colmn:1
10	COLON	:	row:108	colmn:2
6	LCURB	{	row:108	colmn:3
35	PRINTFUNC	printf	row:110	colmn:0
11	LPAR	(	row:110	colmn:1
4	STR	"test line:"	row:110	colmn:2
12	RPAR	)	row:110	colmn:3
9	SEMI	;	row:110	colmn:4
2	IDEN	line	row:111	colmn:0
11	LPAR	(	row:111	colmn:1
1	INT	8	row:111	colmn:2
8	COMMA	,	row:111	colmn:3
1	INT	3	row:111	colmn:4
12	RPAR	)	row:111	colmn:5
9	SEMI	;	row:111	colmn:6
7	RCURB	}	row:113	colmn:0
33	CASESY	case	row:114	colmn:0
1	INT	1	row:114	colmn:1
10	COLON	:	row:114	colmn:2
6	LCURB	{	row:114	colmn:3
35	PRINTFUNC	printf	row:115	colmn:0
11	LPAR	(	row:115	colmn:1
4	STR	"test fib:"	row:115	colmn:2
12	RPAR	)	row:115	colmn:3
9	SEMI	;	row:115	colmn:4
2	IDEN	d	row:116	colmn:0
5	ASSIGN	=	row:116	colmn:1
2	IDEN	fib	row:116	colmn:2
11	LPAR	(	row:116	colmn:3
2	IDEN	coz	row:116	colmn:4
12	RPAR	)	row:116	colmn:5
9	SEMI	;	row:116	colmn:6
35	PRINTFUNC	printf	row:117	colmn:0
11	LPAR	(	row:117	colmn:1
4	STR	"fib="	row:117	colmn:2
8	COMMA	,	row:117	colmn:3
2	IDEN	d	row:117	colmn:4
12	RPAR	)	row:117	colmn:5
9	SEMI	;	row:117	colmn:6
7	RCURB	}	row:119	colmn:0
33	CASESY	case	row:120	colmn:0
1	INT	2	row:120	colmn:1
10	COLON	:	row:120	colmn:2
6	LCURB	{	row:120	colmn:3
30	DOSY	do	row:121	colmn:0
6	LCURB	{	row:121	colmn:1
2	IDEN	sz	row:122	colmn:0
13	LBRAK	[	row:122	colmn:1
2	IDEN	i	row:122	colmn:2
14	RBRAK	]	row:122	colmn:3
5	ASSIGN	=	row:122	colmn:4
3	CHR	'a'	row:122	colmn:5
9	SEMI	;	row:122	colmn:6
2	IDEN	sz2	row:123	colmn:0
13	LBRAK	[	row:123	colmn:1
2	IDEN	i	row:123	colmn:2
14	RBRAK	]	row:123	colmn:3
5	ASSIGN	=	row:123	colmn:4
2	IDEN	i	row:123	colmn:5
9	SEMI	;	row:123	colmn:6
2	IDEN	i	row:124	colmn:0
5	ASSIGN	=	row:124	colmn:1
2	IDEN	i	row:124	colmn:2
15	PLUS	+	row:124	colmn:3
1	INT	1	row:124	colmn:4
9	SEMI	;	row:124	colmn:5
7	RCURB	}	row:125	colmn:0
31	WHILESY	while	row:125	colmn:1
11	LPAR	(	row:125	colmn:2
2	IDEN	i	row:125	colmn:3
20	LS	<	row:125	colmn:4
1	INT	5	row:125	colmn:5
12	RPAR	)	row:125	colmn:6
36	SCANFUNC	scanf	row:129	colmn:0
11	LPAR	(	row:129	colmn:1
2	IDEN	key	row:129	colmn:2
8	COMMA	,	row:129	colmn:3
2	IDEN	a	row:129	colmn:4
12	RPAR	)	row:129	colmn:5
9	SEMI	;	row:129	colmn:6
29	IFSY	if	row:130	colmn:0
11	LPAR	(	row:130	colmn:1
2	IDEN	key	row:130	colmn:2
20	LS	<	row:130	colmn:3
1	INT	3	row:130	colmn:4
12	RPAR	)	row:130	colmn:5
6	LCURB	{	row:130	colmn:6
2	IDEN	a	row:131	colmn:0
5	ASSIGN	=	row:131	colmn:1
2	IDEN	a	row:131	colmn:2
15	PLUS	+	row:131	colmn:3
2	IDEN	b	row:131	colmn:4
9	SEMI	;	row:131	colmn:5
35	PRINTFUNC	printf	row:132	colmn:0
11	LPAR	(	row:132	colmn:1
2	IDEN	a	row:132	colmn:2
12	RPAR	)	row:132	colmn:3
9	SEMI	;	row:132	colmn:4
7	RCURB	}	row:133	colmn:0
29	IFSY	if	row:134	colmn:0
11	LPAR	(	row:134	colmn:1
2	IDEN	key	row:134	colmn:2
22	LSEQU	<=	row:134	colmn:3
1	INT	3	row:134	colmn:4
12	RPAR	)	row:134	colmn:5
6	LCURB	{	row:134	colmn:6
2	IDEN	b	row:135	colmn:0
5	ASSIGN	=	row:135	colmn:1
2	IDEN	b	row:135	colmn:2
16	MINUS	-	row:135	colmn:3
2	IDEN	a	row:135	colmn:4
9	SEMI	;	row:135	colmn:5
2	IDEN	sz2	row:136	colmn:0
13	LBRAK	[	row:136	colmn:1
1	INT	0	row:136	colmn:2
14	RBRAK	]	row:136	colmn:3
5	ASSIGN	=	row:136	colmn:4
2	IDEN	sz2	row:136	colmn:5
13	LBRAK	[	row:136	colmn:6
1	INT	0	row:136	colmn:7
14	RBRAK	]	row:136	colmn:8
15	PLUS	+	row:136	colmn:9
2	IDEN	b	row:136	colmn:10
9	SEMI	;	row:136	colmn:11
2	IDEN	sz	row:137	colmn:0
13	LBRAK	[	row:137	colmn:1
1	INT	0	row:137	colmn:2
14	RBRAK	]	row:137	colmn:3
5	ASSIGN	=	row:137	colmn:4
2	IDEN	sz	row:137	colmn:5
13	LBRAK	[	row:137	colmn:6
1	INT	0	row:137	colmn:7
14	RBRAK	]	row:137	colmn:8
15	PLUS	+	row:137	colmn:9
1	INT	1	row:137	colmn:10
9	SEMI	;	row:137	colmn:11
35	PRINTFUNC	printf	row:138	colmn:0
11	LPAR	(	row:138	colmn:1
2	IDEN	b	row:138	colmn:2
12	RPAR	)	row:138	colmn:3
9	SEMI	;	row:138	colmn:4
35	PRINTFUNC	printf	row:139	colmn:0
11	LPAR	(	row:139	colmn:1
2	IDEN	sz	row:139	colmn:2
13	LBRAK	[	row:139	colmn:3
1	INT	0	row:139	colmn:4
14	RBRAK	]	row:139	colmn:5
12	RPAR	)	row:139	colmn:6
9	SEMI	;	row:139	colmn:7
35	PRINTFUNC	printf	row:140	colmn:0
11	LPAR	(	row:140	colmn:1
2	IDEN	sz2	row:140	colmn:2
13	LBRAK	[	row:140	colmn:3
1	INT	0	row:140	colmn:4
14	RBRAK	]	row:140	colmn:5
12	RPAR	)	row:140	colmn:6
9	SEMI	;	row:140	colmn:7
7	RCURB	}	row:141	colmn:0
29	IFSY	if	row:142	colmn:0
11	LPAR	(	row:142	colmn:1
2	IDEN	key	row:142	colmn:2
19	GT	>	row:142	colmn:3
1	INT	6	row:142	colmn:4
12	RPAR	)	row:142	colmn:5
6	LCURB	{	row:142	colmn:6
2	IDEN	c	row:143	colmn:0
5	ASSIGN	=	row:143	colmn:1
2	IDEN	a	row:143	colmn:2
17	STAR	*	row:143	colmn:3
2	IDEN	b	row:143	colmn:4
9	SEMI	;	row:143	colmn:5
2	IDEN	sz2	row:144	colmn:0
13	LBRAK	[	row:144	colmn:1
1	INT	1	row:144	colmn:2
14	RBRAK	]	row:144	colmn:3
5	ASSIGN	=	row:144	colmn:4
2	IDEN	sz2	row:144	colmn:5
13	LBRAK	[	row:144	colmn:6
1	INT	1	row:144	colmn:7
14	RBRAK	]	row:144	colmn:8
15	PLUS	+	row:144	colmn:9
2	IDEN	c	row:144	colmn:10
9	SEMI	;	row:144	colmn:11
2	IDEN	sz	row:145	colmn:0
13	LBRAK	[	row:145	colmn:1
1	INT	1	row:145	colmn:2
14	RBRAK	]	row:145	colmn:3
5	ASSIGN	=	row:145	colmn:4
2	IDEN	sz	row:145	colmn:5
13	LBRAK	[	row:145	colmn:6
1	INT	1	row:145	colmn:7
14	RBRAK	]	row:145	colmn:8
15	PLUS	+	row:145	colmn:9
1	INT	1	row:145	colmn:10
9	SEMI	;	row:145	colmn:11
35	PRINTFUNC	printf	row:146	colmn:0
11	LPAR	(	row:146	colmn:1
2	IDEN	c	row:146	colmn:2
12	RPAR	)	row:146	colmn:3
9	SEMI	;	row:146	colmn:4
35	PRINTFUNC	printf	row:147	colmn:0
11	LPAR	(	row:147	colmn:1
2	IDEN	sz	row:147	colmn:2
13	LBRAK	[	row:147	colmn:3
1	INT	1	row:147	colmn:4
14	RBRAK	]	row:147	colmn:5
12	RPAR	)	row:147	colmn:6
9	SEMI	;	row:147	colmn:7
35	PRINTFUNC	printf	row:148	colmn:0
11	LPAR	(	row:148	colmn:1
2	IDEN	sz2	row:148	colmn:2
13	LBRAK	[	row:148	colmn:3
1	INT	1	row:148	colmn:4
14	RBRAK	]	row:148	colmn:5
12	RPAR	)	row:148	colmn:6
9	SEMI	;	row:148	colmn:7
7	RCURB	}	row:149	colmn:0
29	IFSY	if	row:150	colmn:0
11	LPAR	(	row:150	colmn:1
2	IDEN	key	row:150	colmn:2
21	GTEQU	>=	row:150	colmn:3
1	INT	6	row:150	colmn:4
12	RPAR	)	row:150	colmn:5
6	LCURB	{	row:150	colmn:6
2	IDEN	d	row:151	colmn:0
5	ASSIGN	=	row:151	colmn:1
15	PLUS	+	row:151	colmn:2
2	IDEN	a	row:151	colmn:3
18	DIV	/	row:151	colmn:4
2	IDEN	b	row:151	colmn:5
9	SEMI	;	row:151	colmn:6
2	IDEN	sz2	row:152	colmn:0
13	LBRAK	[	row:152	colmn:1
1	INT	2	row:152	colmn:2
14	RBRAK	]	row:152	colmn:3
5	ASSIGN	=	row:152	colmn:4
2	IDEN	sz2	row:152	colmn:5
13	LBRAK	[	row:152	colmn:6
1	INT	2	row:152	colmn:7
14	RBRAK	]	row:152	colmn:8
15	PLUS	+	row:152	colmn:9
2	IDEN	d	row:152	colmn:10
9	SEMI	;	row:152	colmn:11
2	IDEN	sz	row:153	colmn:0
13	LBRAK	[	row:153	colmn:1
1	INT	2	row:153	colmn:2
14	RBRAK	]	row:153	colmn:3
5	ASSIGN	=	row:153	colmn:4
2	IDEN	sz	row:153	colmn:5
13	LBRAK	[	row:153	colmn:6
1	INT	2	row:153	colmn:7
14	RBRAK	]	row:153	colmn:8
15	PLUS	+	row:153	colmn:9
1	INT	1	row:153	colmn:10
9	SEMI	;	row:153	colmn:11
35	PRINTFUNC	printf	row:154	colmn:0
11	LPAR	(	row:154	colmn:1
2	IDEN	d	row:154	colmn:2
12	RPAR	)	row:154	colmn:3
9	SEMI	;	row:154	colmn:4
35	PRINTFUNC	printf	row:155	colmn:0
11	LPAR	(	row:155	colmn:1
2	IDEN	sz	row:155	colmn:2
13	LBRAK	[	row:155	colmn:3
1	INT	2	row:155	colmn:4
14	RBRAK	]	row:155	colmn:5
12	RPAR	)	row:155	colmn:6
9	SEMI	;	row:155	colmn:7
35	PRINTFUNC	printf	row:156	colmn:0
11	LPAR	(	row:156	colmn:1
2	IDEN	sz2	row:156	colmn:2
13	LBRAK	[	row:156	colmn:3
1	INT	2	row:156	colmn:4
14	RBRAK	]	row:156	colmn:5
12	RPAR	)	row:156	colmn:6
9	SEMI	;	row:156	colmn:7
7	RCURB	}	row:157	colmn:0
29	IFSY	if	row:158	colmn:0
11	LPAR	(	row:158	colmn:1
2	IDEN	key	row:158	colmn:2
24	NEQU	!=	row:158	colmn:3
1	INT	4	row:158	colmn:4
12	RPAR	)	row:158	colmn:5
6	LCURB	{	row:158	colmn:6
2	IDEN	a	row:159	colmn:0
5	ASSIGN	=	row:159	colmn:1
2	IDEN	a	row:159	colmn:2
16	MINUS	-	row:159	colmn:3
1	INT	1	row:159	colmn:4
18	DIV	/	row:159	colmn:5
2	IDEN	coz	row:159	colmn:6
9	SEMI	;	row:159	colmn:7
2	IDEN	sz2	row:160	colmn:0
13	LBRAK	[	row:160	colmn:1
1	INT	3	row:160	colmn:2
14	RBRAK	]	row:160	colmn:3
5	ASSIGN	=	row:160	colmn:4
2	IDEN	sz2	row:160	colmn:5
13	LBRAK	[	row:160	colmn:6
1	INT	3	row:160	colmn:7
14	RBRAK	]	row:160	colmn:8
15	PLUS	+	row:160	colmn:9
2	IDEN	a	row:160	colmn:10
15	PLUS	+	row:160	colmn:11
3	CHR	'c'	row:160	colmn:12
9	SEMI	;	row:160	colmn:13
2	IDEN	sz	row:161	colmn:0
13	LBRAK	[	row:161	colmn:1
1	INT	3	row:161	colmn:2
14	RBRAK	]	row:161	colmn:3
5	ASSIGN	=	row:161	colmn:4
2	IDEN	sz	row:161	colmn:5
13	LBRAK	[	row:161	colmn:6
1	INT	3	row:161	colmn:7
14	RBRAK	]	row:161	colmn:8
15	PLUS	+	row:161	colmn:9
1	INT	1	row:161	colmn:10
9	SEMI	;	row:161	colmn:11
35	PRINTFUNC	printf	row:162	colmn:0
11	LPAR	(	row:162	colmn:1
2	IDEN	a	row:162	colmn:2
12	RPAR	)	row:162	colmn:3
9	SEMI	;	row:162	colmn:4
35	PRINTFUNC	printf	row:163	colmn:0
11	LPAR	(	row:163	colmn:1
2	IDEN	sz	row:163	colmn:2
13	LBRAK	[	row:163	colmn:3
1	INT	3	row:163	colmn:4
14	RBRAK	]	row:163	colmn:5
12	RPAR	)	row:163	colmn:6
9	SEMI	;	row:163	colmn:7
35	PRINTFUNC	printf	row:164	colmn:0
11	LPAR	(	row:164	colmn:1
2	IDEN	sz2	row:164	colmn:2
13	LBRAK	[	row:164	colmn:3
1	INT	3	row:164	colmn:4
14	RBRAK	]	row:164	colmn:5
12	RPAR	)	row:164	colmn:6
9	SEMI	;	row:164	colmn:7
7	RCURB	}	row:165	colmn:0
29	IFSY	if	row:166	colmn:0
11	LPAR	(	row:166	colmn:1
2	IDEN	key	row:166	colmn:2
23	EQU	==	row:166	colmn:3
1	INT	4	row:166	colmn:4
12	RPAR	)	row:166	colmn:5
6	LCURB	{	row:166	colmn:6
2	IDEN	a	row:167	colmn:0
5	ASSIGN	=	row:167	colmn:1
16	MINUS	-	row:167	colmn:2
2	IDEN	a	row:167	colmn:3
15	PLUS	+	row:167	colmn:4
1	INT	2	row:167	colmn:5
17	STAR	*	row:167	colmn:6
2	IDEN	coz	row:167	colmn:7
9	SEMI	;	row:167	colmn:8
2	IDEN	sz	row:168	colmn:0
13	LBRAK	[	row:168	colmn:1
1	INT	4	row:168	colmn:2
14	RBRAK	]	row:168	colmn:3
5	ASSIGN	=	row:168	colmn:4
2	IDEN	sz	row:168	colmn:5
13	LBRAK	[	row:168	colmn:6
1	INT	4	row:168	colmn:7
14	RBRAK	]	row:168	colmn:8
15	PLUS	+	row:168	colmn:9
1	INT	1	row:168	colmn:10
9	SEMI	;	row:168	colmn:11
35	PRINTFUNC	printf	row:169	colmn:0
11	LPAR	(	row:169	colmn:1
2	IDEN	a	row:169	colmn:2
12	RPAR	)	row:169	colmn:3
9	SEMI	;	row:169	colmn:4
35	PRINTFUNC	printf	row:170	colmn:0
11	LPAR	(	row:170	colmn:1
2	IDEN	sz	row:170	colmn:2
13	LBRAK	[	row:170	colmn:3
1	INT	4	row:170	colmn:4
14	RBRAK	]	row:170	colmn:5
12	RPAR	)	row:170	colmn:6
9	SEMI	;	row:170	colmn:7
35	PRINTFUNC	printf	row:171	colmn:0
11	LPAR	(	row:171	colmn:1
2	IDEN	sz2	row:171	colmn:2
13	LBRAK	[	row:171	colmn:3
1	INT	4	row:171	colmn:4
14	RBRAK	]	row:171	colmn:5
12	RPAR	)	row:171	colmn:6
9	SEMI	;	row:171	colmn:7
7	RCURB	}	row:172	colmn:0
29	IFSY	if	row:173	colmn:0
11	LPAR	(	row:173	colmn:1
2	IDEN	key	row:173	colmn:2
12	RPAR	)	row:173	colmn:3
6	LCURB	{	row:173	colmn:4
35	PRINTFUNC	printf	row:174	colmn:0
11	LPAR	(	row:174	colmn:1
15	PLUS	+	row:174	colmn:2
2	IDEN	a	row:174	colmn:3
12	RPAR	)	row:174	colmn:4
9	SEMI	;	row:174	colmn:5
7	RCURB	}	row:175	colmn:0
7	RCURB	}	row:176	colmn:0
33	CASESY	case	row:177	colmn:0
1	INT	3	row:177	colmn:1
10	COLON	:	row:177	colmn:2
6	LCURB	{	row:177	colmn:3
35	PRINTFUNC	printf	row:178	colmn:0
11	LPAR	(	row:178	colmn:1
4	STR	"test function:"	row:178	colmn:2
12	RPAR	)	row:178	colmn:3
9	SEMI	;	row:178	colmn:4
29	IFSY	if	row:179	colmn:0
11	LPAR	(	row:179	colmn:1
2	IDEN	key	row:179	colmn:2
12	RPAR	)	row:179	colmn:3
2	IDEN	sz2	row:179	colmn:4
13	LBRAK	[	row:179	colmn:5
1	INT	4	row:179	colmn:6
14	RBRAK	]	row:179	colmn:7
5	ASSIGN	=	row:179	colmn:8
2	IDEN	f	row:179	colmn:9
11	LPAR	(	row:179	colmn:10
16	MINUS	-	row:179	colmn:11
1	INT	2	row:179	colmn:12
8	COMMA	,	row:179	colmn:13
1	INT	3	row:179	colmn:14
12	RPAR	)	row:179	colmn:15
15	PLUS	+	row:179	colmn:16
11	LPAR	(	row:179	colmn:17
1	INT	5	row:179	colmn:18
15	PLUS	+	row:179	colmn:19
1	INT	1	row:179	colmn:20
12	RPAR	)	row:179	colmn:21
17	STAR	*	row:179	colmn:22
2	IDEN	coz	row:179	colmn:23
9	SEMI	;	row:179	colmn:24
2	IDEN	t	row:180	colmn:0
11	LPAR	(	row:180	colmn:1
2	IDEN	conb	row:180	colmn:2
12	RPAR	)	row:180	colmn:3
9	SEMI	;	row:180	colmn:4
35	PRINTFUNC	printf	row:181	colmn:0
11	LPAR	(	row:181	colmn:1
2	IDEN	f2	row:181	colmn:2
11	LPAR	(	row:181	colmn:3
3	CHR	'a'	row:181	colmn:4
12	RPAR	)	row:181	colmn:5
12	RPAR	)	row:181	colmn:6
9	SEMI	;	row:181	colmn:7
35	PRINTFUNC	printf	row:182	colmn:0
11	LPAR	(	row:182	colmn:1
2	IDEN	sz2	row:182	colmn:2
13	LBRAK	[	row:182	colmn:3
1	INT	4	row:182	colmn:4
14	RBRAK	]	row:182	colmn:5
12	RPAR	)	row:182	colmn:6
9	SEMI	;	row:182	colmn:7
7	RCURB	}	row:183	colmn:0
33	CASESY	case	row:184	colmn:0
1	INT	4	row:184	colmn:1
10	COLON	:	row:184	colmn:2
6	LCURB	{	row:184	colmn:3
35	PRINTFUNC	printf	row:185	colmn:0
11	LPAR	(	row:185	colmn:1
4	STR	"test switch:"	row:185	colmn:2
12	RPAR	)	row:185	colmn:3
9	SEMI	;	row:185	colmn:4
36	SCANFUNC	scanf	row:186	colmn:0
11	LPAR	(	row:186	colmn:1
2	IDEN	key	row:186	colmn:2
12	RPAR	)	row:186	colmn:3
9	SEMI	;	row:186	colmn:4
32	SWITCHSY	switch	row:187	colmn:0
11	LPAR	(	row:187	colmn:1
2	IDEN	key	row:187	colmn:2
17	STAR	*	row:187	colmn:3
1	INT	1	row:187	colmn:4
12	RPAR	)	row:187	colmn:5
6	LCURB	{	row:187	colmn:6
33	CASESY	case	row:188	colmn:0
1	INT	0	row:188	colmn:1
10	COLON	:	row:188	colmn:2
35	PRINTFUNC	printf	row:188	colmn:3
11	LPAR	(	row:188	colmn:4
4	STR	"key is 0"	row:188	colmn:5
12	RPAR	)	row:188	colmn:6
9	SEMI	;	row:188	colmn:7
33	CASESY	case	row:189	colmn:0
1	INT	1	row:189	colmn:1
10	COLON	:	row:189	colmn:2
35	PRINTFUNC	printf	row:189	colmn:3
11	LPAR	(	row:189	colmn:4
4	STR	"key is "	row:189	colmn:5
8	COMMA	,	row:189	colmn:6
2	IDEN	key	row:189	colmn:7
12	RPAR	)	row:189	colmn:8
9	SEMI	;	row:189	colmn:9
33	CASESY	case	row:190	colmn:0
1	INT	2	row:190	colmn:1
10	COLON	:	row:190	colmn:2
35	PRINTFUNC	printf	row:190	colmn:3
11	LPAR	(	row:190	colmn:4
4	STR	"key is 2"	row:190	colmn:5
12	RPAR	)	row:190	colmn:6
9	SEMI	;	row:190	colmn:7
7	RCURB	}	row:191	colmn:0
36	SCANFUNC	scanf	row:192	colmn:0
11	LPAR	(	row:192	colmn:1
2	IDEN	e	row:192	colmn:2
12	RPAR	)	row:192	colmn:3
9	SEMI	;	row:192	colmn:4
32	SWITCHSY	switch	row:193	colmn:0
11	LPAR	(	row:193	colmn:1
2	IDEN	e	row:193	colmn:2
12	RPAR	)	row:193	colmn:3
6	LCURB	{	row:193	colmn:4
33	CASESY	case	row:194	colmn:0
3	CHR	'a'	row:194	colmn:1
10	COLON	:	row:194	colmn:2
35	PRINTFUNC	printf	row:194	colmn:3
11	LPAR	(	row:194	colmn:4
15	PLUS	+	row:194	colmn:5
15	PLUS	+	row:194	colmn:6
1	INT	2	row:194	colmn:7
12	RPAR	)	row:194	colmn:8
9	SEMI	;	row:194	colmn:9
33	CASESY	case	row:195	colmn:0
3	CHR	'b'	row:195	colmn:1
10	COLON	:	row:195	colmn:2
35	PRINTFUNC	printf	row:195	colmn:3
11	LPAR	(	row:195	colmn:4
15	PLUS	+	row:195	colmn:5
1	INT	2	row:195	colmn:6
15	PLUS	+	row:195	colmn:7
16	MINUS	-	row:195	colmn:8
1	INT	2	row:195	colmn:9
12	RPAR	)	row:195	colmn:10
9	SEMI	;	row:195	colmn:11
7	RCURB	}	row:196	colmn:0
7	RCURB	}	row:198	colmn:0
7	RCURB	}	row:201	colmn:0
2	IDEN	nest	row:204	colmn:0
11	LPAR	(	row:204	colmn:1
12	RPAR	)	row:204	colmn:2
9	SEMI	;	row:204	colmn:3
34	RETURNSY	return	row:205	colmn:0
9	SEMI	;	row:205	colmn:1
7	RCURB	}	row:206	colmn:0
39	ENDOFINPUT	ÿ	row:206	colmn:1
39	ENDOFINPUT	ÿ	row:206	colmn:2
