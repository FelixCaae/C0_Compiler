28	CONSTYP	const	row:0	colmn:3
25	INTYP	int	row:0	colmn:4
2	IDEN	MaxN	row:0	colmn:5
5	ASSIGN	=	row:0	colmn:6
1	INT	100	row:0	colmn:7
9	SEMI	;	row:0	colmn:8
25	INTYP	int	row:1	colmn:0
2	IDEN	n	row:1	colmn:1
9	SEMI	;	row:1	colmn:2
25	INTYP	int	row:2	colmn:0
2	IDEN	s	row:2	colmn:1
9	SEMI	;	row:2	colmn:2
25	INTYP	int	row:3	colmn:0
2	IDEN	i	row:3	colmn:1
8	COMMA	,	row:3	colmn:2
2	IDEN	j	row:3	colmn:3
9	SEMI	;	row:3	colmn:4
25	INTYP	int	row:4	colmn:0
2	IDEN	dyn	row:4	colmn:1
13	LBRAK	[	row:4	colmn:2
1	INT	5050	row:4	colmn:3
14	RBRAK	]	row:4	colmn:4
9	SEMI	;	row:4	colmn:5
25	INTYP	int	row:5	colmn:0
2	IDEN	Mod	row:5	colmn:1
11	LPAR	(	row:5	colmn:2
25	INTYP	int	row:5	colmn:3
2	IDEN	a	row:5	colmn:4
8	COMMA	,	row:5	colmn:5
25	INTYP	int	row:5	colmn:6
2	IDEN	b	row:5	colmn:7
12	RPAR	)	row:5	colmn:8
6	LCURB	{	row:6	colmn:0
29	IFSY	if	row:7	colmn:0
11	LPAR	(	row:7	colmn:1
2	IDEN	a	row:7	colmn:2
20	LS	<	row:7	colmn:3
1	INT	0	row:7	colmn:4
12	RPAR	)	row:7	colmn:5
34	RETURNSY	return	row:7	colmn:6
11	LPAR	(	row:7	colmn:7
2	IDEN	a	row:7	colmn:8
15	PLUS	+	row:7	colmn:9
2	IDEN	b	row:7	colmn:10
12	RPAR	)	row:7	colmn:11
9	SEMI	;	row:7	colmn:12
34	RETURNSY	return	row:8	colmn:0
11	LPAR	(	row:8	colmn:1
2	IDEN	Mod	row:8	colmn:2
11	LPAR	(	row:8	colmn:3
2	IDEN	a	row:8	colmn:4
16	MINUS	-	row:8	colmn:5
2	IDEN	b	row:8	colmn:6
8	COMMA	,	row:8	colmn:7
2	IDEN	b	row:8	colmn:8
12	RPAR	)	row:8	colmn:9
12	RPAR	)	row:8	colmn:10
9	SEMI	;	row:8	colmn:11
7	RCURB	}	row:9	colmn:0
27	NOTYP	void	row:10	colmn:0
37	MAINFUNC	main	row:10	colmn:1
11	LPAR	(	row:10	colmn:2
12	RPAR	)	row:10	colmn:3
6	LCURB	{	row:11	colmn:0
36	SCANFUNC	scanf	row:12	colmn:0
11	LPAR	(	row:12	colmn:1
2	IDEN	n	row:12	colmn:2
12	RPAR	)	row:12	colmn:3
9	SEMI	;	row:12	colmn:4
29	IFSY	if	row:13	colmn:0
11	LPAR	(	row:13	colmn:1
2	IDEN	n	row:13	colmn:2
20	LS	<	row:13	colmn:3
1	INT	0	row:13	colmn:4
12	RPAR	)	row:13	colmn:5
6	LCURB	{	row:14	colmn:0
35	PRINTFUNC	printf	row:15	colmn:0
11	LPAR	(	row:15	colmn:1
4	STR	"n should be bigger or equal to zero"	row:15	colmn:2
12	RPAR	)	row:15	colmn:3
9	SEMI	;	row:15	colmn:4
7	RCURB	}	row:16	colmn:0
29	IFSY	if	row:17	colmn:0
11	LPAR	(	row:17	colmn:1
2	IDEN	n	row:17	colmn:2
19	GT	>	row:17	colmn:3
2	IDEN	MaxN	row:17	colmn:4
12	RPAR	)	row:17	colmn:5
6	LCURB	{	row:18	colmn:0
35	PRINTFUNC	printf	row:19	colmn:0
11	LPAR	(	row:19	colmn:1
4	STR	"n should be less or equal than"	row:19	colmn:2
8	COMMA	,	row:19	colmn:3
2	IDEN	MaxN	row:19	colmn:4
12	RPAR	)	row:19	colmn:5
9	SEMI	;	row:19	colmn:6
7	RCURB	}	row:20	colmn:0
2	IDEN	s	row:21	colmn:0
5	ASSIGN	=	row:21	colmn:1
2	IDEN	n	row:21	colmn:2
17	STAR	*	row:21	colmn:3
11	LPAR	(	row:21	colmn:4
2	IDEN	n	row:21	colmn:5
15	PLUS	+	row:21	colmn:6
1	INT	1	row:21	colmn:7
12	RPAR	)	row:21	colmn:8
9	SEMI	;	row:21	colmn:9
29	IFSY	if	row:22	colmn:0
11	LPAR	(	row:22	colmn:1
2	IDEN	Mod	row:22	colmn:2
11	LPAR	(	row:22	colmn:3
2	IDEN	s	row:22	colmn:4
8	COMMA	,	row:22	colmn:5
1	INT	4	row:22	colmn:6
12	RPAR	)	row:22	colmn:7
24	NEQU	!=	row:22	colmn:8
1	INT	0	row:22	colmn:9
12	RPAR	)	row:22	colmn:10
6	LCURB	{	row:23	colmn:0
35	PRINTFUNC	printf	row:24	colmn:0
11	LPAR	(	row:24	colmn:1
1	INT	0	row:24	colmn:2
12	RPAR	)	row:24	colmn:3
9	SEMI	;	row:24	colmn:4
34	RETURNSY	return	row:25	colmn:0
9	SEMI	;	row:25	colmn:1
7	RCURB	}	row:26	colmn:0
2	IDEN	s	row:27	colmn:0
5	ASSIGN	=	row:27	colmn:1
2	IDEN	s	row:27	colmn:2
18	DIV	/	row:27	colmn:3
1	INT	4	row:27	colmn:4
9	SEMI	;	row:27	colmn:5
2	IDEN	dyn	row:28	colmn:0
13	LBRAK	[	row:28	colmn:1
15	PLUS	+	row:28	colmn:2
1	INT	0	row:28	colmn:3
16	MINUS	-	row:28	colmn:4
1	INT	1	row:28	colmn:5
15	PLUS	+	row:28	colmn:6
1	INT	2	row:28	colmn:7
14	RBRAK	]	row:28	colmn:8
5	ASSIGN	=	row:28	colmn:9
1	INT	1	row:28	colmn:10
9	SEMI	;	row:28	colmn:11
2	IDEN	i	row:29	colmn:0
5	ASSIGN	=	row:29	colmn:1
1	INT	1	row:29	colmn:2
9	SEMI	;	row:29	colmn:3
30	DOSY	do	row:31	colmn:0
6	LCURB	{	row:31	colmn:1
2	IDEN	j	row:32	colmn:0
5	ASSIGN	=	row:32	colmn:1
2	IDEN	s	row:32	colmn:2
9	SEMI	;	row:32	colmn:3
30	DOSY	do	row:34	colmn:0
6	LCURB	{	row:34	colmn:1
29	IFSY	if	row:35	colmn:0
11	LPAR	(	row:35	colmn:1
2	IDEN	j	row:35	colmn:2
16	MINUS	-	row:35	colmn:3
2	IDEN	i	row:35	colmn:4
19	GT	>	row:35	colmn:5
1	INT	0	row:35	colmn:6
12	RPAR	)	row:35	colmn:7
6	LCURB	{	row:36	colmn:0
2	IDEN	dyn	row:37	colmn:0
13	LBRAK	[	row:37	colmn:1
2	IDEN	j	row:37	colmn:2
14	RBRAK	]	row:37	colmn:3
5	ASSIGN	=	row:37	colmn:4
2	IDEN	dyn	row:37	colmn:5
13	LBRAK	[	row:37	colmn:6
2	IDEN	j	row:37	colmn:7
14	RBRAK	]	row:37	colmn:8
15	PLUS	+	row:37	colmn:9
2	IDEN	dyn	row:37	colmn:10
13	LBRAK	[	row:37	colmn:11
2	IDEN	j	row:37	colmn:12
16	MINUS	-	row:37	colmn:13
2	IDEN	i	row:37	colmn:14
14	RBRAK	]	row:37	colmn:15
9	SEMI	;	row:37	colmn:16
7	RCURB	}	row:38	colmn:0
2	IDEN	j	row:39	colmn:0
5	ASSIGN	=	row:39	colmn:1
2	IDEN	j	row:39	colmn:2
16	MINUS	-	row:39	colmn:3
1	INT	1	row:39	colmn:4
9	SEMI	;	row:39	colmn:5
7	RCURB	}	row:40	colmn:0
31	WHILESY	while	row:40	colmn:1
11	LPAR	(	row:40	colmn:2
2	IDEN	j	row:40	colmn:3
21	GTEQU	>=	row:40	colmn:4
2	IDEN	i	row:40	colmn:5
12	RPAR	)	row:40	colmn:6
2	IDEN	i	row:41	colmn:0
5	ASSIGN	=	row:41	colmn:1
2	IDEN	i	row:41	colmn:2
15	PLUS	+	row:41	colmn:3
1	INT	1	row:41	colmn:4
9	SEMI	;	row:41	colmn:5
7	RCURB	}	row:42	colmn:0
31	WHILESY	while	row:42	colmn:1
11	LPAR	(	row:42	colmn:2
2	IDEN	i	row:42	colmn:3
22	LSEQU	<=	row:42	colmn:4
2	IDEN	n	row:42	colmn:5
12	RPAR	)	row:42	colmn:6
35	PRINTFUNC	printf	row:43	colmn:0
11	LPAR	(	row:43	colmn:1
2	IDEN	dyn	row:43	colmn:2
13	LBRAK	[	row:43	colmn:3
2	IDEN	s	row:43	colmn:4
14	RBRAK	]	row:43	colmn:5
18	DIV	/	row:43	colmn:6
1	INT	2	row:43	colmn:7
12	RPAR	)	row:43	colmn:8
9	SEMI	;	row:43	colmn:9
7	RCURB	}	row:44	colmn:0
39	ENDOFINPUT	ÿ	row:44	colmn:1
39	ENDOFINPUT	ÿ	row:44	colmn:2
