25	INTYP	int	row:1	colmn:0
2	IDEN	mod	row:1	colmn:1
11	LPAR	(	row:1	colmn:2
25	INTYP	int	row:1	colmn:3
2	IDEN	a	row:1	colmn:4
8	COMMA	,	row:1	colmn:5
25	INTYP	int	row:1	colmn:6
2	IDEN	b	row:1	colmn:7
12	RPAR	)	row:1	colmn:8
6	LCURB	{	row:2	colmn:0
29	IFSY	if	row:3	colmn:0
11	LPAR	(	row:3	colmn:1
2	IDEN	a	row:3	colmn:2
20	LS	<	row:3	colmn:3
1	INT	0	row:3	colmn:4
12	RPAR	)	row:3	colmn:5
34	RETURNSY	return	row:3	colmn:6
11	LPAR	(	row:3	colmn:7
2	IDEN	a	row:3	colmn:8
15	PLUS	+	row:3	colmn:9
2	IDEN	b	row:3	colmn:10
12	RPAR	)	row:3	colmn:11
9	SEMI	;	row:3	colmn:12
34	RETURNSY	return	row:4	colmn:0
11	LPAR	(	row:4	colmn:1
2	IDEN	mod	row:4	colmn:2
11	LPAR	(	row:4	colmn:3
2	IDEN	a	row:4	colmn:4
16	MINUS	-	row:4	colmn:5
2	IDEN	b	row:4	colmn:6
8	COMMA	,	row:4	colmn:7
2	IDEN	b	row:4	colmn:8
12	RPAR	)	row:4	colmn:9
12	RPAR	)	row:4	colmn:10
9	SEMI	;	row:4	colmn:11
7	RCURB	}	row:5	colmn:0
25	INTYP	int	row:6	colmn:0
2	IDEN	ping	row:6	colmn:1
11	LPAR	(	row:6	colmn:2
25	INTYP	int	row:6	colmn:3
2	IDEN	a	row:6	colmn:4
12	RPAR	)	row:6	colmn:5
6	LCURB	{	row:7	colmn:0
25	INTYP	int	row:8	colmn:0
2	IDEN	target	row:8	colmn:1
9	SEMI	;	row:8	colmn:2
2	IDEN	target	row:9	colmn:0
5	ASSIGN	=	row:9	colmn:1
1	INT	10	row:9	colmn:2
9	SEMI	;	row:9	colmn:3
29	IFSY	if	row:10	colmn:0
11	LPAR	(	row:10	colmn:1
2	IDEN	a	row:10	colmn:2
19	GT	>	row:10	colmn:3
2	IDEN	target	row:10	colmn:4
12	RPAR	)	row:10	colmn:5
6	LCURB	{	row:11	colmn:0
34	RETURNSY	return	row:12	colmn:0
11	LPAR	(	row:12	colmn:1
2	IDEN	ping	row:12	colmn:2
11	LPAR	(	row:12	colmn:3
2	IDEN	target	row:12	colmn:4
16	MINUS	-	row:12	colmn:5
11	LPAR	(	row:12	colmn:6
2	IDEN	a	row:12	colmn:7
16	MINUS	-	row:12	colmn:8
2	IDEN	target	row:12	colmn:9
16	MINUS	-	row:12	colmn:10
1	INT	1	row:12	colmn:11
12	RPAR	)	row:12	colmn:12
12	RPAR	)	row:12	colmn:13
12	RPAR	)	row:12	colmn:14
9	SEMI	;	row:12	colmn:15
7	RCURB	}	row:13	colmn:0
29	IFSY	if	row:14	colmn:0
11	LPAR	(	row:14	colmn:1
2	IDEN	a	row:14	colmn:2
20	LS	<	row:14	colmn:3
2	IDEN	target	row:14	colmn:4
12	RPAR	)	row:14	colmn:5
6	LCURB	{	row:15	colmn:0
34	RETURNSY	return	row:16	colmn:0
11	LPAR	(	row:16	colmn:1
2	IDEN	ping	row:16	colmn:2
11	LPAR	(	row:16	colmn:3
2	IDEN	target	row:16	colmn:4
15	PLUS	+	row:16	colmn:5
11	LPAR	(	row:16	colmn:6
2	IDEN	target	row:16	colmn:7
16	MINUS	-	row:16	colmn:8
2	IDEN	a	row:16	colmn:9
16	MINUS	-	row:16	colmn:10
1	INT	1	row:16	colmn:11
12	RPAR	)	row:16	colmn:12
12	RPAR	)	row:16	colmn:13
12	RPAR	)	row:16	colmn:14
9	SEMI	;	row:16	colmn:15
7	RCURB	}	row:17	colmn:0
29	IFSY	if	row:18	colmn:0
11	LPAR	(	row:18	colmn:1
2	IDEN	a	row:18	colmn:2
23	EQU	==	row:18	colmn:3
2	IDEN	target	row:18	colmn:4
12	RPAR	)	row:18	colmn:5
6	LCURB	{	row:19	colmn:0
34	RETURNSY	return	row:20	colmn:0
11	LPAR	(	row:20	colmn:1
2	IDEN	a	row:20	colmn:2
12	RPAR	)	row:20	colmn:3
9	SEMI	;	row:20	colmn:4
7	RCURB	}	row:21	colmn:0
7	RCURB	}	row:22	colmn:0
25	INTYP	int	row:23	colmn:0
2	IDEN	ischar	row:23	colmn:1
11	LPAR	(	row:23	colmn:2
25	INTYP	int	row:23	colmn:3
2	IDEN	a	row:23	colmn:4
12	RPAR	)	row:23	colmn:5
6	LCURB	{	row:24	colmn:0
29	IFSY	if	row:25	colmn:0
11	LPAR	(	row:25	colmn:1
2	IDEN	a	row:25	colmn:2
23	EQU	==	row:25	colmn:3
1	INT	95	row:25	colmn:4
12	RPAR	)	row:25	colmn:5
34	RETURNSY	return	row:25	colmn:6
11	LPAR	(	row:25	colmn:7
1	INT	1	row:25	colmn:8
12	RPAR	)	row:25	colmn:9
9	SEMI	;	row:25	colmn:10
29	IFSY	if	row:26	colmn:0
11	LPAR	(	row:26	colmn:1
2	IDEN	a	row:26	colmn:2
21	GTEQU	>=	row:26	colmn:3
1	INT	65	row:26	colmn:4
12	RPAR	)	row:26	colmn:5
29	IFSY	if	row:27	colmn:0
11	LPAR	(	row:27	colmn:1
2	IDEN	a	row:27	colmn:2
22	LSEQU	<=	row:27	colmn:3
1	INT	90	row:27	colmn:4
12	RPAR	)	row:27	colmn:5
34	RETURNSY	return	row:27	colmn:6
11	LPAR	(	row:27	colmn:7
1	INT	1	row:27	colmn:8
12	RPAR	)	row:27	colmn:9
9	SEMI	;	row:27	colmn:10
29	IFSY	if	row:28	colmn:0
11	LPAR	(	row:28	colmn:1
2	IDEN	a	row:28	colmn:2
21	GTEQU	>=	row:28	colmn:3
1	INT	97	row:28	colmn:4
12	RPAR	)	row:28	colmn:5
29	IFSY	if	row:29	colmn:0
11	LPAR	(	row:29	colmn:1
2	IDEN	a	row:29	colmn:2
22	LSEQU	<=	row:29	colmn:3
1	INT	122	row:29	colmn:4
12	RPAR	)	row:29	colmn:5
34	RETURNSY	return	row:29	colmn:6
11	LPAR	(	row:29	colmn:7
1	INT	1	row:29	colmn:8
12	RPAR	)	row:29	colmn:9
9	SEMI	;	row:29	colmn:10
29	IFSY	if	row:30	colmn:0
11	LPAR	(	row:30	colmn:1
2	IDEN	a	row:30	colmn:2
23	EQU	==	row:30	colmn:3
1	INT	95	row:30	colmn:4
12	RPAR	)	row:30	colmn:5
34	RETURNSY	return	row:30	colmn:6
11	LPAR	(	row:30	colmn:7
1	INT	1	row:30	colmn:8
12	RPAR	)	row:30	colmn:9
9	SEMI	;	row:30	colmn:10
34	RETURNSY	return	row:31	colmn:0
11	LPAR	(	row:31	colmn:1
1	INT	0	row:31	colmn:2
12	RPAR	)	row:31	colmn:3
9	SEMI	;	row:31	colmn:4
7	RCURB	}	row:32	colmn:0
26	CHARTYP	char	row:33	colmn:0
2	IDEN	tochar	row:33	colmn:1
11	LPAR	(	row:33	colmn:2
25	INTYP	int	row:33	colmn:3
2	IDEN	a	row:33	colmn:4
12	RPAR	)	row:33	colmn:5
6	LCURB	{	row:34	colmn:0
26	CHARTYP	char	row:35	colmn:0
2	IDEN	c	row:35	colmn:1
9	SEMI	;	row:35	colmn:2
2	IDEN	c	row:36	colmn:0
5	ASSIGN	=	row:36	colmn:1
3	CHR	'_'	row:36	colmn:2
9	SEMI	;	row:36	colmn:3
29	IFSY	if	row:37	colmn:0
11	LPAR	(	row:37	colmn:1
2	IDEN	ischar	row:37	colmn:2
11	LPAR	(	row:37	colmn:3
2	IDEN	a	row:37	colmn:4
12	RPAR	)	row:37	colmn:5
12	RPAR	)	row:37	colmn:6
6	LCURB	{	row:38	colmn:0
2	IDEN	c	row:39	colmn:0
5	ASSIGN	=	row:39	colmn:1
2	IDEN	a	row:39	colmn:2
9	SEMI	;	row:39	colmn:3
7	RCURB	}	row:40	colmn:0
34	RETURNSY	return	row:41	colmn:0
11	LPAR	(	row:41	colmn:1
2	IDEN	c	row:41	colmn:2
12	RPAR	)	row:41	colmn:3
9	SEMI	;	row:41	colmn:4
7	RCURB	}	row:42	colmn:0
25	INTYP	int	row:43	colmn:0
2	IDEN	itself	row:43	colmn:1
11	LPAR	(	row:43	colmn:2
25	INTYP	int	row:43	colmn:3
2	IDEN	a	row:43	colmn:4
12	RPAR	)	row:43	colmn:5
6	LCURB	{	row:44	colmn:0
34	RETURNSY	return	row:45	colmn:0
11	LPAR	(	row:45	colmn:1
2	IDEN	a	row:45	colmn:2
12	RPAR	)	row:45	colmn:3
9	SEMI	;	row:45	colmn:4
7	RCURB	}	row:46	colmn:0
25	INTYP	int	row:47	colmn:0
2	IDEN	max	row:47	colmn:1
11	LPAR	(	row:47	colmn:2
25	INTYP	int	row:47	colmn:3
2	IDEN	a	row:47	colmn:4
8	COMMA	,	row:47	colmn:5
25	INTYP	int	row:47	colmn:6
2	IDEN	b	row:47	colmn:7
12	RPAR	)	row:47	colmn:8
6	LCURB	{	row:48	colmn:0
29	IFSY	if	row:49	colmn:0
11	LPAR	(	row:49	colmn:1
2	IDEN	a	row:49	colmn:2
21	GTEQU	>=	row:49	colmn:3
2	IDEN	b	row:49	colmn:4
12	RPAR	)	row:49	colmn:5
34	RETURNSY	return	row:49	colmn:6
11	LPAR	(	row:49	colmn:7
2	IDEN	a	row:49	colmn:8
12	RPAR	)	row:49	colmn:9
9	SEMI	;	row:49	colmn:10
34	RETURNSY	return	row:50	colmn:0
11	LPAR	(	row:50	colmn:1
2	IDEN	b	row:50	colmn:2
12	RPAR	)	row:50	colmn:3
9	SEMI	;	row:50	colmn:4
7	RCURB	}	row:51	colmn:0
25	INTYP	int	row:52	colmn:0
2	IDEN	min	row:52	colmn:1
11	LPAR	(	row:52	colmn:2
25	INTYP	int	row:52	colmn:3
2	IDEN	a	row:52	colmn:4
8	COMMA	,	row:52	colmn:5
25	INTYP	int	row:52	colmn:6
2	IDEN	b	row:52	colmn:7
12	RPAR	)	row:52	colmn:8
6	LCURB	{	row:53	colmn:0
29	IFSY	if	row:54	colmn:0
11	LPAR	(	row:54	colmn:1
2	IDEN	a	row:54	colmn:2
22	LSEQU	<=	row:54	colmn:3
2	IDEN	b	row:54	colmn:4
12	RPAR	)	row:54	colmn:5
34	RETURNSY	return	row:54	colmn:6
11	LPAR	(	row:54	colmn:7
2	IDEN	a	row:54	colmn:8
12	RPAR	)	row:54	colmn:9
9	SEMI	;	row:54	colmn:10
34	RETURNSY	return	row:55	colmn:0
11	LPAR	(	row:55	colmn:1
2	IDEN	b	row:55	colmn:2
12	RPAR	)	row:55	colmn:3
9	SEMI	;	row:55	colmn:4
7	RCURB	}	row:56	colmn:0
25	INTYP	int	row:57	colmn:0
2	IDEN	power	row:57	colmn:1
11	LPAR	(	row:57	colmn:2
25	INTYP	int	row:57	colmn:3
2	IDEN	a	row:57	colmn:4
8	COMMA	,	row:57	colmn:5
25	INTYP	int	row:57	colmn:6
2	IDEN	b	row:57	colmn:7
12	RPAR	)	row:57	colmn:8
6	LCURB	{	row:58	colmn:0
25	INTYP	int	row:59	colmn:0
2	IDEN	i	row:59	colmn:1
8	COMMA	,	row:59	colmn:2
2	IDEN	c	row:59	colmn:3
9	SEMI	;	row:59	colmn:4
2	IDEN	i	row:60	colmn:0
5	ASSIGN	=	row:60	colmn:1
1	INT	0	row:60	colmn:2
9	SEMI	;	row:60	colmn:3
2	IDEN	c	row:61	colmn:0
5	ASSIGN	=	row:61	colmn:1
2	IDEN	a	row:61	colmn:2
9	SEMI	;	row:61	colmn:3
30	DOSY	do	row:63	colmn:0
6	LCURB	{	row:63	colmn:1
2	IDEN	a	row:64	colmn:0
5	ASSIGN	=	row:64	colmn:1
2	IDEN	a	row:64	colmn:2
17	STAR	*	row:64	colmn:3
2	IDEN	c	row:64	colmn:4
9	SEMI	;	row:64	colmn:5
2	IDEN	i	row:65	colmn:0
5	ASSIGN	=	row:65	colmn:1
2	IDEN	i	row:65	colmn:2
15	PLUS	+	row:65	colmn:3
1	INT	1	row:65	colmn:4
9	SEMI	;	row:65	colmn:5
7	RCURB	}	row:66	colmn:0
31	WHILESY	while	row:66	colmn:1
11	LPAR	(	row:66	colmn:2
2	IDEN	i	row:66	colmn:3
15	PLUS	+	row:66	colmn:4
1	INT	1	row:66	colmn:5
20	LS	<	row:66	colmn:6
2	IDEN	b	row:66	colmn:7
12	RPAR	)	row:66	colmn:8
9	SEMI	;	row:66	colmn:9
34	RETURNSY	return	row:67	colmn:0
11	LPAR	(	row:67	colmn:1
2	IDEN	a	row:67	colmn:2
12	RPAR	)	row:67	colmn:3
9	SEMI	;	row:67	colmn:4
7	RCURB	}	row:68	colmn:0
25	INTYP	int	row:69	colmn:0
2	IDEN	get0	row:69	colmn:1
11	LPAR	(	row:69	colmn:2
12	RPAR	)	row:69	colmn:3
6	LCURB	{	row:70	colmn:0
25	INTYP	int	row:71	colmn:0
2	IDEN	i	row:71	colmn:1
9	SEMI	;	row:71	colmn:2
2	IDEN	i	row:72	colmn:0
5	ASSIGN	=	row:72	colmn:1
1	INT	0	row:72	colmn:2
9	SEMI	;	row:72	colmn:3
30	DOSY	do	row:73	colmn:0
9	SEMI	;	row:73	colmn:1
31	WHILESY	while	row:73	colmn:2
11	LPAR	(	row:73	colmn:3
2	IDEN	i	row:73	colmn:4
12	RPAR	)	row:73	colmn:5
9	SEMI	;	row:73	colmn:6
34	RETURNSY	return	row:74	colmn:0
11	LPAR	(	row:74	colmn:1
2	IDEN	i	row:74	colmn:2
12	RPAR	)	row:74	colmn:3
9	SEMI	;	row:74	colmn:4
7	RCURB	}	row:75	colmn:0
27	NOTYP	void	row:76	colmn:0
2	IDEN	alphabet	row:76	colmn:1
11	LPAR	(	row:76	colmn:2
12	RPAR	)	row:76	colmn:3
6	LCURB	{	row:77	colmn:0
25	INTYP	int	row:78	colmn:0
2	IDEN	i	row:78	colmn:1
9	SEMI	;	row:78	colmn:2
26	CHARTYP	char	row:79	colmn:0
2	IDEN	ch	row:79	colmn:1
9	SEMI	;	row:79	colmn:2
2	IDEN	i	row:80	colmn:0
5	ASSIGN	=	row:80	colmn:1
1	INT	50	row:80	colmn:2
9	SEMI	;	row:80	colmn:3
30	DOSY	do	row:82	colmn:0
6	LCURB	{	row:82	colmn:1
29	IFSY	if	row:83	colmn:0
11	LPAR	(	row:83	colmn:1
2	IDEN	ischar	row:83	colmn:2
11	LPAR	(	row:83	colmn:3
2	IDEN	i	row:83	colmn:4
12	RPAR	)	row:83	colmn:5
12	RPAR	)	row:83	colmn:6
6	LCURB	{	row:84	colmn:0
2	IDEN	ch	row:85	colmn:0
5	ASSIGN	=	row:85	colmn:1
2	IDEN	i	row:85	colmn:2
9	SEMI	;	row:85	colmn:3
35	PRINTFUNC	printf	row:86	colmn:0
11	LPAR	(	row:86	colmn:1
2	IDEN	ch	row:86	colmn:2
12	RPAR	)	row:86	colmn:3
9	SEMI	;	row:86	colmn:4
7	RCURB	}	row:87	colmn:0
2	IDEN	i	row:88	colmn:0
5	ASSIGN	=	row:88	colmn:1
2	IDEN	i	row:88	colmn:2
15	PLUS	+	row:88	colmn:3
1	INT	1	row:88	colmn:4
9	SEMI	;	row:88	colmn:5
7	RCURB	}	row:89	colmn:0
31	WHILESY	while	row:89	colmn:1
11	LPAR	(	row:89	colmn:2
2	IDEN	i	row:89	colmn:3
24	NEQU	!=	row:89	colmn:4
1	INT	128	row:89	colmn:5
12	RPAR	)	row:89	colmn:6
9	SEMI	;	row:89	colmn:7
7	RCURB	}	row:90	colmn:0
25	INTYP	int	row:91	colmn:0
2	IDEN	f3	row:91	colmn:1
11	LPAR	(	row:91	colmn:2
12	RPAR	)	row:91	colmn:3
6	LCURB	{	row:92	colmn:0
34	RETURNSY	return	row:93	colmn:0
11	LPAR	(	row:93	colmn:1
1	INT	10	row:93	colmn:2
12	RPAR	)	row:93	colmn:3
9	SEMI	;	row:93	colmn:4
7	RCURB	}	row:94	colmn:0
27	NOTYP	void	row:95	colmn:0
2	IDEN	fun_def_test	row:95	colmn:1
11	LPAR	(	row:95	colmn:2
12	RPAR	)	row:95	colmn:3
6	LCURB	{	row:95	colmn:4
25	INTYP	int	row:96	colmn:0
2	IDEN	c	row:96	colmn:1
8	COMMA	,	row:96	colmn:2
2	IDEN	c2	row:96	colmn:3
9	SEMI	;	row:96	colmn:4
35	PRINTFUNC	printf	row:97	colmn:0
11	LPAR	(	row:97	colmn:1
4	STR	"Please input a number (1-100): "	row:97	colmn:2
12	RPAR	)	row:97	colmn:3
9	SEMI	;	row:97	colmn:4
36	SCANFUNC	scanf	row:98	colmn:0
11	LPAR	(	row:98	colmn:1
2	IDEN	c	row:98	colmn:2
12	RPAR	)	row:98	colmn:3
9	SEMI	;	row:98	colmn:4
35	PRINTFUNC	printf	row:99	colmn:0
11	LPAR	(	row:99	colmn:1
4	STR	"the max number is:"	row:99	colmn:2
8	COMMA	,	row:99	colmn:3
2	IDEN	max	row:99	colmn:4
11	LPAR	(	row:99	colmn:5
2	IDEN	itself	row:99	colmn:6
11	LPAR	(	row:99	colmn:7
2	IDEN	c	row:99	colmn:8
12	RPAR	)	row:99	colmn:9
8	COMMA	,	row:99	colmn:10
2	IDEN	f3	row:99	colmn:11
11	LPAR	(	row:99	colmn:12
12	RPAR	)	row:99	colmn:13
12	RPAR	)	row:99	colmn:14
12	RPAR	)	row:99	colmn:15
9	SEMI	;	row:99	colmn:16
35	PRINTFUNC	printf	row:100	colmn:0
11	LPAR	(	row:100	colmn:1
4	STR	"Please input two numbers (1-100): "	row:100	colmn:2
12	RPAR	)	row:100	colmn:3
9	SEMI	;	row:100	colmn:4
36	SCANFUNC	scanf	row:101	colmn:0
11	LPAR	(	row:101	colmn:1
2	IDEN	c	row:101	colmn:2
8	COMMA	,	row:101	colmn:3
2	IDEN	c2	row:101	colmn:4
12	RPAR	)	row:101	colmn:5
9	SEMI	;	row:101	colmn:6
35	PRINTFUNC	printf	row:102	colmn:0
11	LPAR	(	row:102	colmn:1
4	STR	"the power is"	row:102	colmn:2
8	COMMA	,	row:102	colmn:3
2	IDEN	power	row:102	colmn:4
11	LPAR	(	row:102	colmn:5
2	IDEN	min	row:102	colmn:6
11	LPAR	(	row:102	colmn:7
2	IDEN	c	row:102	colmn:8
8	COMMA	,	row:102	colmn:9
2	IDEN	itself	row:102	colmn:10
11	LPAR	(	row:102	colmn:11
2	IDEN	c2	row:102	colmn:12
12	RPAR	)	row:102	colmn:13
12	RPAR	)	row:102	colmn:14
8	COMMA	,	row:102	colmn:15
2	IDEN	max	row:102	colmn:16
11	LPAR	(	row:102	colmn:17
2	IDEN	c	row:102	colmn:18
8	COMMA	,	row:102	colmn:19
2	IDEN	c2	row:102	colmn:20
12	RPAR	)	row:102	colmn:21
12	RPAR	)	row:102	colmn:22
12	RPAR	)	row:102	colmn:23
9	SEMI	;	row:102	colmn:24
7	RCURB	}	row:103	colmn:0
25	INTYP	int	row:104	colmn:0
2	IDEN	arg4	row:104	colmn:1
11	LPAR	(	row:104	colmn:2
25	INTYP	int	row:104	colmn:3
2	IDEN	a	row:104	colmn:4
8	COMMA	,	row:104	colmn:5
25	INTYP	int	row:104	colmn:6
2	IDEN	b	row:104	colmn:7
8	COMMA	,	row:104	colmn:8
25	INTYP	int	row:104	colmn:9
2	IDEN	c	row:104	colmn:10
8	COMMA	,	row:104	colmn:11
25	INTYP	int	row:104	colmn:12
2	IDEN	d	row:104	colmn:13
12	RPAR	)	row:104	colmn:14
6	LCURB	{	row:105	colmn:0
34	RETURNSY	return	row:106	colmn:0
11	LPAR	(	row:106	colmn:1
2	IDEN	a	row:106	colmn:2
15	PLUS	+	row:106	colmn:3
2	IDEN	b	row:106	colmn:4
15	PLUS	+	row:106	colmn:5
2	IDEN	c	row:106	colmn:6
15	PLUS	+	row:106	colmn:7
2	IDEN	d	row:106	colmn:8
12	RPAR	)	row:106	colmn:9
9	SEMI	;	row:106	colmn:10
7	RCURB	}	row:107	colmn:0
25	INTYP	int	row:108	colmn:0
2	IDEN	arg12	row:108	colmn:1
11	LPAR	(	row:108	colmn:2
25	INTYP	int	row:108	colmn:3
2	IDEN	a	row:108	colmn:4
8	COMMA	,	row:108	colmn:5
25	INTYP	int	row:108	colmn:6
2	IDEN	b	row:108	colmn:7
8	COMMA	,	row:108	colmn:8
25	INTYP	int	row:108	colmn:9
2	IDEN	c	row:108	colmn:10
8	COMMA	,	row:108	colmn:11
25	INTYP	int	row:108	colmn:12
2	IDEN	d	row:108	colmn:13
8	COMMA	,	row:108	colmn:14
26	CHARTYP	char	row:108	colmn:15
2	IDEN	e	row:108	colmn:16
8	COMMA	,	row:108	colmn:17
26	CHARTYP	char	row:108	colmn:18
2	IDEN	f	row:108	colmn:19
8	COMMA	,	row:108	colmn:20
25	INTYP	int	row:108	colmn:21
2	IDEN	g	row:108	colmn:22
8	COMMA	,	row:108	colmn:23
25	INTYP	int	row:108	colmn:24
2	IDEN	h	row:108	colmn:25
8	COMMA	,	row:108	colmn:26
26	CHARTYP	char	row:108	colmn:27
2	IDEN	i	row:108	colmn:28
8	COMMA	,	row:108	colmn:29
25	INTYP	int	row:108	colmn:30
2	IDEN	j	row:108	colmn:31
8	COMMA	,	row:108	colmn:32
25	INTYP	int	row:108	colmn:33
2	IDEN	k	row:108	colmn:34
8	COMMA	,	row:108	colmn:35
25	INTYP	int	row:108	colmn:36
2	IDEN	l	row:108	colmn:37
12	RPAR	)	row:108	colmn:38
6	LCURB	{	row:109	colmn:0
35	PRINTFUNC	printf	row:110	colmn:0
11	LPAR	(	row:110	colmn:1
2	IDEN	e	row:110	colmn:2
12	RPAR	)	row:110	colmn:3
9	SEMI	;	row:110	colmn:4
34	RETURNSY	return	row:111	colmn:0
11	LPAR	(	row:111	colmn:1
2	IDEN	a	row:111	colmn:2
15	PLUS	+	row:111	colmn:3
2	IDEN	b	row:111	colmn:4
15	PLUS	+	row:111	colmn:5
2	IDEN	c	row:111	colmn:6
15	PLUS	+	row:111	colmn:7
2	IDEN	d	row:111	colmn:8
15	PLUS	+	row:111	colmn:9
2	IDEN	e	row:111	colmn:10
15	PLUS	+	row:111	colmn:11
2	IDEN	f	row:111	colmn:12
15	PLUS	+	row:111	colmn:13
2	IDEN	g	row:111	colmn:14
15	PLUS	+	row:111	colmn:15
2	IDEN	h	row:111	colmn:16
15	PLUS	+	row:111	colmn:17
2	IDEN	i	row:111	colmn:18
15	PLUS	+	row:111	colmn:19
2	IDEN	j	row:111	colmn:20
15	PLUS	+	row:111	colmn:21
2	IDEN	k	row:111	colmn:22
15	PLUS	+	row:111	colmn:23
2	IDEN	l	row:111	colmn:24
12	RPAR	)	row:111	colmn:25
9	SEMI	;	row:111	colmn:26
7	RCURB	}	row:112	colmn:0
27	NOTYP	void	row:113	colmn:0
2	IDEN	testarg	row:113	colmn:1
11	LPAR	(	row:113	colmn:2
12	RPAR	)	row:113	colmn:3
6	LCURB	{	row:114	colmn:0
28	CONSTYP	const	row:115	colmn:0
25	INTYP	int	row:115	colmn:1
2	IDEN	_1	row:115	colmn:2
5	ASSIGN	=	row:115	colmn:3
1	INT	1	row:115	colmn:4
9	SEMI	;	row:115	colmn:5
28	CONSTYP	const	row:116	colmn:0
25	INTYP	int	row:116	colmn:1
2	IDEN	_2	row:116	colmn:2
5	ASSIGN	=	row:116	colmn:3
1	INT	2	row:116	colmn:4
9	SEMI	;	row:116	colmn:5
25	INTYP	int	row:117	colmn:0
2	IDEN	_3	row:117	colmn:1
8	COMMA	,	row:117	colmn:2
2	IDEN	_4	row:117	colmn:3
9	SEMI	;	row:117	colmn:4
26	CHARTYP	char	row:118	colmn:0
2	IDEN	_e	row:118	colmn:1
9	SEMI	;	row:118	colmn:2
2	IDEN	_3	row:119	colmn:0
5	ASSIGN	=	row:119	colmn:1
1	INT	3	row:119	colmn:2
9	SEMI	;	row:119	colmn:3
2	IDEN	_4	row:120	colmn:0
5	ASSIGN	=	row:120	colmn:1
1	INT	4	row:120	colmn:2
9	SEMI	;	row:120	colmn:3
2	IDEN	_e	row:121	colmn:0
5	ASSIGN	=	row:121	colmn:1
3	CHR	'e'	row:121	colmn:2
9	SEMI	;	row:121	colmn:3
35	PRINTFUNC	printf	row:122	colmn:0
11	LPAR	(	row:122	colmn:1
4	STR	"4argfunc call,result should be 6:"	row:122	colmn:2
8	COMMA	,	row:122	colmn:3
2	IDEN	arg4	row:122	colmn:4
11	LPAR	(	row:122	colmn:5
1	INT	1	row:122	colmn:6
8	COMMA	,	row:122	colmn:7
2	IDEN	_1	row:122	colmn:8
8	COMMA	,	row:122	colmn:9
1	INT	2	row:122	colmn:10
8	COMMA	,	row:122	colmn:11
2	IDEN	_2	row:122	colmn:12
12	RPAR	)	row:122	colmn:13
12	RPAR	)	row:122	colmn:14
9	SEMI	;	row:122	colmn:15
35	PRINTFUNC	printf	row:123	colmn:0
11	LPAR	(	row:123	colmn:1
4	STR	"12arg func call result should be 327"	row:123	colmn:2
8	COMMA	,	row:123	colmn:3
2	IDEN	arg12	row:123	colmn:4
11	LPAR	(	row:123	colmn:5
2	IDEN	_1	row:123	colmn:6
8	COMMA	,	row:123	colmn:7
2	IDEN	_2	row:123	colmn:8
8	COMMA	,	row:123	colmn:9
2	IDEN	_3	row:123	colmn:10
8	COMMA	,	row:123	colmn:11
2	IDEN	_4	row:123	colmn:12
8	COMMA	,	row:123	colmn:13
2	IDEN	_e	row:123	colmn:14
8	COMMA	,	row:123	colmn:15
3	CHR	'f'	row:123	colmn:16
8	COMMA	,	row:123	colmn:17
1	INT	1	row:123	colmn:18
8	COMMA	,	row:123	colmn:19
1	INT	2	row:123	colmn:20
8	COMMA	,	row:123	colmn:21
3	CHR	'i'	row:123	colmn:22
8	COMMA	,	row:123	colmn:23
2	IDEN	_1	row:123	colmn:24
8	COMMA	,	row:123	colmn:25
1	INT	2	row:123	colmn:26
8	COMMA	,	row:123	colmn:27
1	INT	3	row:123	colmn:28
12	RPAR	)	row:123	colmn:29
12	RPAR	)	row:123	colmn:30
9	SEMI	;	row:123	colmn:31
7	RCURB	}	row:124	colmn:0
27	NOTYP	void	row:125	colmn:0
2	IDEN	testmod	row:125	colmn:1
11	LPAR	(	row:125	colmn:2
12	RPAR	)	row:125	colmn:3
6	LCURB	{	row:126	colmn:0
25	INTYP	int	row:127	colmn:0
2	IDEN	result	row:127	colmn:1
9	SEMI	;	row:127	colmn:2
35	PRINTFUNC	printf	row:128	colmn:0
11	LPAR	(	row:128	colmn:1
4	STR	"10 mod 3 ="	row:128	colmn:2
8	COMMA	,	row:128	colmn:3
2	IDEN	mod	row:128	colmn:4
11	LPAR	(	row:128	colmn:5
1	INT	10	row:128	colmn:6
8	COMMA	,	row:128	colmn:7
1	INT	3	row:128	colmn:8
12	RPAR	)	row:128	colmn:9
12	RPAR	)	row:128	colmn:10
9	SEMI	;	row:128	colmn:11
35	PRINTFUNC	printf	row:129	colmn:0
11	LPAR	(	row:129	colmn:1
4	STR	"17 mod 4 ="	row:129	colmn:2
8	COMMA	,	row:129	colmn:3
2	IDEN	mod	row:129	colmn:4
11	LPAR	(	row:129	colmn:5
1	INT	17	row:129	colmn:6
8	COMMA	,	row:129	colmn:7
1	INT	4	row:129	colmn:8
12	RPAR	)	row:129	colmn:9
12	RPAR	)	row:129	colmn:10
9	SEMI	;	row:129	colmn:11
35	PRINTFUNC	printf	row:130	colmn:0
11	LPAR	(	row:130	colmn:1
4	STR	"100 mod 5 ="	row:130	colmn:2
8	COMMA	,	row:130	colmn:3
2	IDEN	mod	row:130	colmn:4
11	LPAR	(	row:130	colmn:5
1	INT	100	row:130	colmn:6
8	COMMA	,	row:130	colmn:7
1	INT	5	row:130	colmn:8
12	RPAR	)	row:130	colmn:9
12	RPAR	)	row:130	colmn:10
9	SEMI	;	row:130	colmn:11
35	PRINTFUNC	printf	row:131	colmn:0
11	LPAR	(	row:131	colmn:1
4	STR	"0 mod 10 ="	row:131	colmn:2
8	COMMA	,	row:131	colmn:3
2	IDEN	mod	row:131	colmn:4
11	LPAR	(	row:131	colmn:5
1	INT	0	row:131	colmn:6
8	COMMA	,	row:131	colmn:7
1	INT	10	row:131	colmn:8
12	RPAR	)	row:131	colmn:9
12	RPAR	)	row:131	colmn:10
9	SEMI	;	row:131	colmn:11
7	RCURB	}	row:132	colmn:0
27	NOTYP	void	row:133	colmn:0
2	IDEN	testping	row:133	colmn:1
11	LPAR	(	row:133	colmn:2
12	RPAR	)	row:133	colmn:3
6	LCURB	{	row:134	colmn:0
2	IDEN	ping	row:135	colmn:0
11	LPAR	(	row:135	colmn:1
1	INT	1	row:135	colmn:2
12	RPAR	)	row:135	colmn:3
9	SEMI	;	row:135	colmn:4
2	IDEN	ping	row:136	colmn:0
11	LPAR	(	row:136	colmn:1
1	INT	20	row:136	colmn:2
12	RPAR	)	row:136	colmn:3
9	SEMI	;	row:136	colmn:4
7	RCURB	}	row:137	colmn:0
27	NOTYP	void	row:138	colmn:0
37	MAINFUNC	main	row:138	colmn:1
11	LPAR	(	row:138	colmn:2
12	RPAR	)	row:138	colmn:3
6	LCURB	{	row:139	colmn:0
25	INTYP	int	row:140	colmn:0
2	IDEN	var1	row:140	colmn:1
8	COMMA	,	row:140	colmn:2
2	IDEN	var2	row:140	colmn:3
9	SEMI	;	row:140	colmn:4
2	IDEN	var1	row:141	colmn:0
5	ASSIGN	=	row:141	colmn:1
2	IDEN	min	row:141	colmn:2
11	LPAR	(	row:141	colmn:3
1	INT	5	row:141	colmn:4
8	COMMA	,	row:141	colmn:5
1	INT	2	row:141	colmn:6
12	RPAR	)	row:141	colmn:7
9	SEMI	;	row:141	colmn:8
2	IDEN	var2	row:142	colmn:0
5	ASSIGN	=	row:142	colmn:1
2	IDEN	max	row:142	colmn:2
11	LPAR	(	row:142	colmn:3
1	INT	5	row:142	colmn:4
8	COMMA	,	row:142	colmn:5
1	INT	2	row:142	colmn:6
12	RPAR	)	row:142	colmn:7
9	SEMI	;	row:142	colmn:8
2	IDEN	fun_def_test	row:143	colmn:0
11	LPAR	(	row:143	colmn:1
12	RPAR	)	row:143	colmn:2
9	SEMI	;	row:143	colmn:3
2	IDEN	alphabet	row:144	colmn:0
11	LPAR	(	row:144	colmn:1
12	RPAR	)	row:144	colmn:2
9	SEMI	;	row:144	colmn:3
2	IDEN	testarg	row:145	colmn:0
11	LPAR	(	row:145	colmn:1
12	RPAR	)	row:145	colmn:2
9	SEMI	;	row:145	colmn:3
2	IDEN	testmod	row:146	colmn:0
11	LPAR	(	row:146	colmn:1
12	RPAR	)	row:146	colmn:2
9	SEMI	;	row:146	colmn:3
2	IDEN	testping	row:147	colmn:0
11	LPAR	(	row:147	colmn:1
12	RPAR	)	row:147	colmn:2
9	SEMI	;	row:147	colmn:3
7	RCURB	}	row:148	colmn:0
39	ENDOFINPUT	ÿ	row:148	colmn:1
39	ENDOFINPUT	ÿ	row:148	colmn:2
